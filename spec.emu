<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Pattern Matching
stage: 1
contributors:
  - Daniel Rosenwasser
  - Jack Works
  - Jordan Harband
  - Mark Cohen
  - Ross Kirsling
  - Tab Atkins
  - Yulia Startsev
</pre>

<style>
#sec-placeholder, [href="#sec-placeholder"] {
  display: none;
}
</style>
<script>
  Array.from(document.querySelectorAll('ol.toc li'), function (node) {
    if (node.querySelector(':scope > [href="#sec-placeholder"]')) {
      node.style.display = 'none';
    }
  });
</script>

<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

<emu-clause id="sec-ecmascript-data-types-and-values" aoid="Type">
  <h1>ECMAScript Data Types and Values</h1>
  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript Language Types</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-ecmascript-language-types-symbol-type">
      <h1>The Symbol Type</h1>
      <emu-clause id="sec-well-known-symbols">
        <h1>Well-Known Symbols</h1>
        <emu-table id="table-1" caption="Well-known Symbols">
          <table>
            <tbody>
            <tr>
              <th>
                Specification Name
              </th>
              <th>
                [[Description]]
              </th>
              <th>
                Value and Purpose
              </th>
            </tr>
            <tr>
              <td>
                <ins><dfn>@@matcher</dfn></ins>
              </td>
              <td>
                <ins>`"Symbol.matcher"`</ins>
              </td>
              <td>
                <ins>A method that performs custom pattern matching semantics. Called by the semantics of the `match` expression.</ins>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-intrinsic-matcher">
  <h1>Misc</h1>

  <emu-clause id="sec-create-match-result" type="abstract operation">
    <h1>
      CreateMatchResultObject (
        _matched_: a Boolean,
        optional _value_: an ECMAScript language value,
      ): an Object that conforms to the MatchResult interface
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).
      1. Perform ! CreateDataPropertyOrThrow(_obj_, *"matched"*, _matched_).
      1. If _matched_ is *true*, then
        1. Assert: _value_ is present.
        1. Perform ! CreateDataPropertyOrThrow(_obj_, *"value"*, _value_).
      1. Else,
        1. Assert: _value_ is not present.
      1. Return _obj_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-class-matcher">
    <h1>Class matcher</h1>
    <emu-clause id="sec-error-matcher">
      <h1>Error [ @@matcher ] ( _value_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. If _value_ does not have a [[ErrorData]] internal slot, return CreateMatchResultObject(*false*).
        1. Let _self_ be the *this* value.
        1. Let _constructor_ be ? Get(_value_, "constructor").
        1. If Type(_constructor_) is not Function, return CreateMatchResultObject(*false*).
        1. If _self_ is _constructor_, return CreateMatchResultObject(*true*, _value_).
        1. Let _name_ be ? Get(_self_, *"name"*).
        1. If _name_ is not String, return CreateMatchResultObject(*false*).
        1. Let _valueName_ be ? Get(_constructor_, *"name"*).
        1. If _name_ is _valueName_, return CreateMatchResultObject(*true*, _value_).
        1. Return CreateMatchResultObject(*false*).
      </emu-alg>
      <emu-note type="editor">
        TODO: remove this section and update section 20.5.2
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
  <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
  <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
  <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

  <emu-clause id="sec-match-expression">
    <h1>Match Expression</h1>
    <emu-clause id="sec-match-expression-syntax">
      <h1>Syntax</h1>
      <emu-note type="editor">Work in progress.</emu-note>
      <emu-grammar type="definition">
        MatchExpression ::
          `match` [no LineTerminator here] `(` Expression `)` [no LineTerminator here] `{` MatchClauses? `}`

        MatchClauses :
          MatchClause
          MatchClauses MatchClause

        MatchClause :
          `when` `(` MatchPattern `)` `if` `(` Expression `)` `:` Expression
          `when` `(` MatchPattern `)` `:` Expression
          `if` `(` Expression `)` `:` Expression
          `default` `:` Expression

        MatchPattern :
          CombinedMatchPattern
          InterpolationPattern
          IdentifierMatchPattern
          NearLiteralMatchPattern
          ObjectMatchPattern
          ArrayMatchPattern
          `(` MatchPattern `)`

        CombinedMatchPattern:
          MatchPattern `or` MatchPattern
          MatchPattern `and` MatchPattern

        InterpolationPattern:
          `${` Expression `}` `with` MatchPattern
          `${` Expression `}`

        IdentifierMatchPattern :
          Identifier

        NearLiteralMatchPattern :
          NullLiteral
          BooleanLiteral
          NumericLiteral
          StringLiteral
          RegularExpressionLiteral `with` MatchPattern
          RegularExpressionLiteral
          TemplateLiteral[~Tagged]
          `+` NumericLiteral
          `-` NumericLiteral
          `+` `Infinity`
          `-` `Infinity`
          `+` `NaN`
          `-` `NaN`

        ObjectMatchPattern :
          `{` `}`
          `{` MatchRestProperty `}`
          `{` MatchPropertyList `}`
          `{` MatchPropertyList `,` MatchRestProperty? `}`

        ArrayMatchPattern :
          `[` Elision? MatchRestElement? `]`
          `[` MatchElementList `]`
          `[` MatchElementList `,` Elision? MatchRestElement? `]`

        MatchRestProperty :
          `...` IdentifierMatchPattern

        MatchPropertyList :
          MatchProperty
          MatchPropertyList `,` MatchProperty

        MatchElementList :
          MatchElisionElement
          MatchElementList `,` MatchElisionElement

        MatchElisionElement :
          Elision? MatchPattern

        MatchProperty :
          IdentifierMatchPattern
          PropertyName `:` MatchPattern

        MatchRestElement :
          `...` MatchPattern?

      </emu-grammar>
      <emu-note>
        `undefined`, `NaN`, and `Infinity` are covered by the IdentifierMatchPattern, but `+NaN`, `-NaN`, `+Infinity`, and `-Infinity` are covered by the NearLiteralMatchPattern.
      </emu-note>
      <emu-note>
        No Initializer is allowed in the current syntax. See <a href="https://github.com/tc39/proposal-pattern-matching/#default-values">https://github.com/tc39/proposal-pattern-matching/#default-values</a>
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-match-expression-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-note type="editor">This section has not written in normative spec language yet.</emu-note>
      <emu-grammar>
        MatchClauses :
          MatchClause
          MatchClauses MatchClause
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if there are more than one `default` `:` clause.</li>
        <li>It is a Syntax Error if any other clauses follow the `default` `:` clause.</li>
      </ul>
      <emu-grammar>
        NearLiteralMatchPattern :
          RegularExpressionLiteral `with` MatchPattern
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if the named capture group inside RegularExpressionLiteral cannot be covered by Identifier. For example, <code>/a(?&lt;if&gt;.+)/</code> is a syntax error when used in match pattern.</li>
      </ul>
      <emu-grammar>
        MatchPattern :
          CombinedMatchPattern
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if the combined match pattern has both `|` and `&` at the same level without a `()`. For example, `a | b & c` is an early error, `a | (b & c)` or `(a | b) & c` is okay.</li>
      </ul>
    </emu-clause>
    <emu-clause id="sec-match-expression-runtime-semantics">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        MatchExpression ::
          `match` `(` Expression `)` `{` MatchClauses? `}`
      </emu-grammar>
      <emu-alg>
        1. Let _matchableRef_ be the result of evaluating Expression.
        1. Let _matchable_ be ? GetValue(_matchableRef_).
        1. If MatchClauses is not present, throw a *TypeError* exception.
        1. Let _cacheGroup_ be ! Construct(%WeakMap%, a new Empty List).
        1. Let _iterators_ be ! Construct(%Set%, a new Empty List).
        1. Perform ! CreateDataPropertyOrThrow(_cacheGroup_, "IteratorToClose", iterators).
        1. Let _result_ be ? MatchClausesEvaluation of MatchClauses with argument _matchable_ and _cacheGroup_.
        1. Let _iteratorRecords_ be a new empty List.
        1. For each element _iter_ of _iterators_.[[SetData]], do
          1. Append _iter_.[[CachedIterator]] to _iteratorRecords_.
        1. Perform ? CloseIterators(_iteratorRecords_).
        1. If _result_.[[Matched]] is *true*, return _result_.[[Value]].
        1. Throw a *TypeError* exception.
      </emu-alg>
      <emu-note>
        The object _cacheGroup_ is not accessible from user code. An implementation may choose to avoid the actual creation of the object.
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-match-clauses-evaluation" type="sdo">
      <h1>Runtime Semantics: MatchClausesEvaluation></h1>
      <p>The syntax-directed operation MatchClausesEvaluation takes argument _matchable_ (an ECMAScript language value) and _cacheGroup_ (a %WeakMap%) and returns either a normal completion containing a Match Record or an abrupt completion. It is defined piecewise over the following productions:</p>
      <emu-grammar>
        MatchClauses : MatchClause
      </emu-grammar>
      <emu-alg>
        1. Return ? MatchClauseEvaluation of MatchClause with argument _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchClauses : MatchClauses MatchClause
      </emu-grammar>
      <emu-alg>
        1. Let _result_ be ? MatchClausesEvaluation of MatchClauses with argument _matchable_ and _cacheGroup_.
        1. If _result_.[[Matched]] is *true*, return _result_.
        1. Return ? MatchClauseEvaluation of MatchClause with argument _matchable_ and _cacheGroup_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-match-clause-evaluation" type="sdo">
      <h1>Runtime Semantics: MatchClauseEvaluation</h1>
      <p>The syntax-directed operation MatchClauseEvaluation takes argument _matchable_ (an ECMAScript language value) and _cacheGroup_ (a %WeakMap%) and returns either a normal completion containing a Match Record or an abrupt completion. It is defined piecewise over the following productions:</p>
      <emu-grammar>
        MatchClause : `when` `(` MatchPattern `)` `if` `(` Expression `)` `:` Expression
      </emu-grammar>
      <emu-alg>
        1. Let _closure_ be a new Abstract Closure with parameters () that captures _matchable_, _cacheGroup_, MatchPattern, the first Expression, and the second Expression and performs the following steps when called:
          1. Let _matches_ be ? MatchPatternMatches of MatchPattern with arguments _matchable_ and _cacheGroup_.
          1. If _matches_ is *false*, return Match Record { [[Matched]]: false, [[Value]]: unused }.
          1. Let _ifRef_ be the result of evaluating the first Expression.
          1. Let _ifVal_ be ToBoolean(? GetValue(_ifRef_)).
          1. If _ifVal_ is *false*, return Match Record { [[Matched]]: *false*, [[Value]]: unused }.
          1. Let _exprRef_ be evaluating the second Expression.
          1. Let _exprVal_ be ? GetValue(_exprRef_).
          1. Return Match Record { [[Matched]]: *true*, [[Value]]: _exprVal_ }.
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _matchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Set the running execution context's LexicalEnvironment to _matchEnv_.
        1. Let _result_ be _closure_ ().
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return _result_.
      </emu-alg>
      <emu-grammar>
        MatchClause : `when` `(` MatchPattern `)` `:` Expression
      </emu-grammar>
      <emu-alg>
        1. Let _closure_ be a new Abstract Closure with parameters () that captures _matchable_, _cacheGroup_, MatchPattern, and Expression and performs the following steps when called:
          1. Let _matches_ be ? MatchPatternMatches of MatchPattern with arguments _matchable_ and _cacheGroup_.
          1. If _matches_ is *false*, return Match Record { [[Matched]]: false, [[Value]]: unused }.
          1. Let _exprRef_ be evaluating the second Expression.
          1. Let _exprVal_ be ? GetValue(_exprRef_).
          1. Return Match Record { [[Matched]]: *true*, [[Value]]: _exprVal_ }.
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _matchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Set the running execution context's LexicalEnvironment to _matchEnv_.
        1. Let _result_ be _closure_ ().
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return _result_.
      </emu-alg>
      <emu-grammar>
        MatchClause : `if` `(` Expression `)` `:` Expression
      </emu-grammar>
      <emu-alg>
        1. Let _ifRef_ be the result of evaluating the first Expression.
        1. Let _ifVal_ be ToBoolean(? GetValue(_ifRef_)).
        1. If _ifVal_ is *false*, return Match Record { [[Matched]]: *false*, [[Value]]: unused }.
        1. Let _exprRef_ be evaluating the second Expression.
        1. Let _exprVal_ be ? GetValue(_exprRef_).
        1. Return Match Record { [[Matched]]: *true*, [[Value]]: _exprVal_ }.
      </emu-alg>
      <emu-grammar>
        MatchClause : `default` `:` Expression
      </emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be evaluating the Expression.
        1. Let _exprVal_ be ? GetValue(_exprRef_).
        1. Return Match Record { [[Matched]]: *true*, [[Value]]: _exprVal_ }.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-match-pattern-matches" type="sdo">
      <h1>Runtime Semantics: MatchPatternMatches</h1>
      <p>The syntax-directed operation MatchPatternMatches takes argument _matchable_ (an ECMAScript language value) and _cacheGroup_ (a %WeakMap%) and returns either a normal completion containing a Boolean or an abrupt completion. It is defined piecewise over the following productions:</p>
      <emu-grammar>
        MatchPattern : CombinedMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? CombinedMatchPatternMatches of CombinedMatchPattern with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : InterpolationPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? InterpolationPatternMatches of InterpolationPattern with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : IdentifierMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _identifier_ be the Identifier that is covered by IdentifierMatchPattern.
        1. Let _name_ be the StringValue of _identifier_.
        1. If _name_ is *"Infinity"*, return SameValue(_matchable_, *Infinity*).
        1. If _name_ is *"undefined"*, return SameValue(_matchable_, *undefined*).
        1. If _name_ is *"NaN"*, return SameValue(_matchable_, *NaN*).
        1. Perform AddMatchBinding(_name_[0], _matchable_).
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        MatchPattern : NearLiteralMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? NearLiteralMatchPatternMatches of NearLiteralMatchPattern with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : ObjectMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? DestructuringMatchPatternMatches of ObjectMatchPattern with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : ArrayMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? DestructuringMatchPatternMatches of ArrayMatchPattern with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : `(` MatchPattern `)`
      </emu-grammar>
      <emu-alg>
        1. Return ? MatchPatternMatches of MatchPattern with argument _matchable_ and _cacheGroup_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-combined-match-pattern-matches" type="sdo">
      <h1>Runtime Semantics: CombinedMatchPatternMatches</h1>
      <p>The syntax-directed operation CombinedMatchPatternMatches takes argument _matchable_ (an ECMAScript language value) and _cacheGroup_ (a %WeakMap%) and returns either a normal completion containing a Boolean or an abrupt completion. It is defined piecewise over the following productions:</p>
      <emu-grammar>
        CombinedMatchPattern : MatchPattern `or` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _leftMatches_ be ? MatchPatternMatches of the first MatchPattern with arguments _matchable_ and _cacheGroup_.
        1. If _leftMatches_ is *true*, return *true*.
        1. Return ? MatchPatternMatches of the second MatchPattern with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        CombinedMatchPattern : MatchPattern `and` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _leftMatches_ be ? MatchPatternMatches of the first MatchPattern with arguments _matchable_ and _cacheGroup_.
        1. If _leftMatches_ is *false*, return *false*.
        1. Return ? MatchPatternMatches of the second MatchPattern with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-interpolation-pattern-matches" type="sdo">
      <h1>Runtime Semantics: InterpolationPatternMatches</h1>
      <p>The syntax-directed operation InterpolationPatternMatches takes argument _matchable_ (an ECMAScript language value) and _cacheGroup_ (a %WeakMap%) and returns either a normal completion containing a Boolean or an abrupt completion. It is defined piecewise over the following productions:</p>
      <emu-grammar>
        InterpolationPattern : `${` Expression `}`
      </emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be evaluating the Expression.
        1. Let _exprVal_ be ? GetValue(_exprRef_).
        1. Let _result_ be ? InvokeCustomMatcher(_exprVal_, _matchable_).
        1. If _result_ is an ECMAScript language value, return *true*.
        1. Return _result_.
      </emu-alg>
      <emu-grammar>
        InterpolationPattern : `${` Expression `}` `with` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be evaluating the Expression.
        1. Let _exprVal_ be ? GetValue(_exprRef_).
        1. Let _result_ be ? InvokeCustomMatcher(_exprVal_, _matchable_).
        1. If _result_ is *false*, return *false*.
        1. If _result_ is an ECMAScript language value, then
          1. Return ? MatchPatternMatches of MatchPattern with arguments _result_ and _cacheGroup_.
        1. Return ? MatchPatternMatches of MatchPattern with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-near-literal-match-pattern-matches" type="sdo">
      <h1>Runtime Semantics: NearLiteralMatchPatternMatches</h1>
      <p>The syntax-directed operation NearLiteralMatchPatternMatches takes argument _matchable_ (an ECMAScript language value) and _cacheGroup_ (a %WeakMap%) and returns either a normal completion containing a Boolean or an abrupt completion. It is defined piecewise over the following productions:</p>
      <emu-grammar>
        NearLiteralMatchPattern : NullLiteral
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, *null*).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : BooleanLiteral
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, the result of evaluating BooleanLiteral).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : NumericLiteral
      </emu-grammar>
      <emu-alg>
        1. Let _numeric_ be the result of evaluating NumericLiteral.
        1. NOTE: TODO: *-0*<sub>ùîΩ</sub> is handled already, but when there is no explicit `+` sign, the next line should use SameValueZero.
        1. Return SameValue(_matchable_, _numeric_).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, the result of evaluating StringLiteral).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : RegularExpressionLiteral `with` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _regexp_ be the result of evaluating RegularExpressionLiteral.
        1. If Type(_matchable_) is not a String, return *false*.
        1. Let _result_ be ? RegExpBuiltinExec(_regexp_, _matchable_).
        1. If _result_ is *null*, return *false*.
        1. Perform RegularExpressionNamedCaptureGroupBindingInitialization(_result_).
        1. Return ? MatchPatternMatches of MatchPattern with arguments _result_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : RegularExpressionLiteral
      </emu-grammar>
      <emu-alg>
        1. Let _regexp_ be the result of evaluating RegularExpressionLiteral.
        1. If Type(_matchable_) is not a String, return *false*.
        1. Let _result_ be ? RegExpBuiltinExec(_regexp_, _matchable_).
        1. If _result_ is *null*, return *false*.
        1. Perform RegularExpressionNamedCaptureGroupBindingInitialization(_result_).
        1. Return *true*.
      </emu-alg>
      <emu-note>
        The object that returned from RegExpBuiltinExec in this Abstract Operation is not accessible from user code. An implementation may choose to avoid the actual creation of the object.
      </emu-note>
      <emu-grammar>
        NearLiteralMatchPattern : TemplateLiteral[~Tagged]
      </emu-grammar>
      <emu-alg>
        1. Let _strRef_ be the result of evaluating TemplateLiteral.
        1. Let _str_ be ? GetValue(_strRef_).
        1. Return SameValue(_matchable_, _str_).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : `+` NumericLiteral
      </emu-grammar>
      <emu-alg>
        1. Let _num_ be the result of evaluating NumericLiteral.
        1. Return SameValueZero(_matchable_, _num_).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : `-` NumericLiteral
      </emu-grammar>
      <emu-alg>
        1. Let _num_ be the result of evaluating NumericLiteral.
        1. Return SameValueZero(_matchable_, -_num_).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : `+` `Infinity`
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, *Infinity*).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : `-` `Infinity`
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, *-Infinity*).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : `+` `NaN`
        NearLiteralMatchPattern : `-` `NaN`
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, *NaN*).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-destructuring-match-pattern-matches" type="sdo">
      <h1>Runtime Semantics: DestructuringMatchPatternMatches</h1>
      <p>The syntax-directed operation DestructuringMatchPatternMatches takes argument _matchable_ (an ECMAScript language value) and _cacheGroup_ (a %WeakMap%) and returns either a normal completion containing a Boolean or an abrupt completion. It is defined piecewise over the following productions:</p>
      <emu-grammar>
        ObjectMatchPattern : `{` `}`
      </emu-grammar>
      <emu-alg>
        1. If Type(_matchable_) is not Object, return *false*.
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        ObjectMatchPattern : `{` MatchRestProperty `}`
      </emu-grammar>
      <emu-alg>
        1. Perform ? MatchRestPropertyEvaluation of MatchRestProperty with arguments _rest_, _cacheGroup_ and a new empty List.
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        ObjectMatchPattern : `{` MatchPropertyList `}`
      </emu-grammar>
      <emu-alg>
        1. If Type(_matchable_) is not Object, return *false*.
        1. Let _result_ be ? MatchPropertyEvaluation of MatchPropertyList with arguments _matchable_ and _cacheGroup_.
        1. If _result_ is a List, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        ObjectMatchPattern : `{` MatchPropertyList `,` MatchRestProperty? `}`
      </emu-grammar>
      <emu-alg>
        1. If Type(_matchable_) is not Object, return *false*.
        1. Let _result_ be ? MatchPropertyEvaluation of MatchPropertyList with arguments _matchable_ and _cacheGroup_.
        1. If _result_ is *false*, return *false*.
        1. If MatchRestProperty is present, performs MatchRestPropertyEvaluation of MatchRestProperty with arguments _rest_, _cacheGroup_ and _result_.
        1. Return _result_.
      </emu-alg>
      <emu-grammar>
        ArrayMatchPattern : `[` Elision? MatchRestElement? `]`
      </emu-grammar>
      <emu-alg>
        1. If ? MatchCachedIsIterable(_cacheGroup_, _matchable_) is *false*, return *false*.
        1. Let _index_ be Record { [[LastIndex]]: -1 }.
        1. If Elision is present, then
          1. Let _result_ be ? MatchElementEvaluation of Elision with arguments _matchable_, _cacheGroup_ and _index_.
          1. If _result_ is *false*, return *false*.
        1. If MatchRestElement is present, then
          1. Return ? MatchElementEvaluation of MatchRestElement with arguments _matchable_, _cacheGroup_ and _index_.
        1. Return ? MatchIteratorLengthMatch(_cacheGroup_, _matchable_, index.[[LastIndex]]).
      </emu-alg>
      <emu-grammar>
        ArrayMatchPattern : `[` MatchElementList `]`
      </emu-grammar>
      <emu-alg>
        1. If ? MatchCachedIsIterable(_cacheGroup_, _matchable_) is *false*, return *false*.
        1. Let _index_ be Record { [[LastIndex]]: -1 }.
        1. Let _result_ be ? MatchElementEvaluation of MatchElementList with arguments _matchable_, _cacheGroup_ and _index_.
        1. If _result_ is *false*, return *false*.
        1. Return ? MatchIteratorLengthMatch(_cacheGroup_, _matchable_, index.[[LastIndex]]).
      </emu-alg>
      <emu-grammar>
        ArrayMatchPattern : `[` MatchElementList `,` Elision? MatchRestElement? `]`
      </emu-grammar>
      <emu-alg>
        1. If ? MatchCachedIsIterable(_cacheGroup_, _matchable_) is *false*, return *false*.
        1. Let _index_ be Record { [[LastIndex]]: -1 }.
        1. Let _result_ be ? MatchElementEvaluation of MatchElementList with arguments _matchable_, _cacheGroup_ and _index_.
        1. If _result_ is *false*, return *false*.
        1. If Elision is present, then
          1. Let _result_ be ? MatchElementEvaluation of Elision with arguments _matchable_, _cacheGroup_ and _index_.
          1. If _result_ is *false*, return *false*.
        1. If MatchRestElement is present, then
          1. Return ? MatchElementEvaluation of MatchRestElement with arguments _matchable_, _cacheGroup_ and _index_.
        1. Return ? MatchIteratorLengthMatch(_cacheGroup_, _matchable_, index.[[LastIndex]]).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-match-property-evaluation" type="sdo">
      <h1>Runtime Semantics: MatchPropertyEvaluation</h1>
      <p>The syntax-directed operation MatchPropertyEvaluation takes argument _matchable_ (an ECMAScript language value) and _cacheGroup_ (a %WeakMap%) and returns either a normal completion containing a *false* (not matched) or a List (excluded name for rest match) or an abrupt completion. It is defined piecewise over the following productions:</p>
      <emu-grammar>
        MatchPropertyList : MatchProperty
      </emu-grammar>
      <emu-alg>
        1. Return ? MatchPropertyEvaluation of MatchProperty with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchPropertyList : MatchPropertyList `,` MatchProperty
      </emu-grammar>
      <emu-alg>
        1. Let _result_ be ? MatchPropertyEvaluation of MatchPropertyList with arguments _matchable_ and _cacheGroup_.
        1. If _result_ is *false*, return *false*.
        1. Let _result2_ be ? MatchPropertyEvaluation of MatchProperty with arguments _matchable_ and _cacheGroup_.
        1. If _result2_ is *false*, return *false*.
        1. Return the list-concatenation of _result_ and _result2_.
      </emu-alg>
      <emu-grammar>
        MatchProperty : IdentifierMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _identifier_ be the Identifier that is covered by IdentifierMatchPattern.
        1. Let _name_ be the StringValue of _identifier_.
        1. If ? MatchCachedHasProperty(_cacheGroup_, _matchable_, _name_) is *false*, return *false*.
        1. Let _value_ be ? MatchCachedGet(_cacheGroup_, _matchable_, _name_).
        1. Perform AddMatchBinding(_name_, _value_).
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        MatchProperty : PropertyName `:` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating PropertyName.
        1. ReturnIfAbrupt(propKey).
        1. If ? MatchCachedHasProperty(_cacheGroup_, _matchable_, _propKey_) is *false*, return *false*.
        1. Let _value_ be ? MatchCachedGet(_cacheGroup_, _matchable_, _propKey_).
        1. Return ? MatchPatternMatches of MatchPattern with arguments _value_ and _cacheGroup_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-match-rest-property-evaluation" type="sdo">
      <h1>Runtime Semantics: MatchRestPropertyEvaluation</h1>
      <p>The syntax-directed operation MatchRestPropertyEvaluation takes argument _matchable_ (an ECMAScript language value), _cacheGroup_ (a %WeakMap%) and _excludedNames_ (a List) and returns unused or an abrupt completion. It is defined piecewise over the following productions:</p>
      <emu-grammar>
        MatchRestProperty : `...` IdentifierMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _identifier_ be the Identifier that is covered by IdentifierMatchPattern.
        1. Let _name_ be the StringValue of _identifier_.
        1. Let _rest_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ? CopyDataProperties(_rest_, _matchable_, _excludedNames_).
        1. Perform AddMatchBinding(_name_, _rest).
        1. Return unused.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-match-element-evaluation" type="sdo">
      <h1>Runtime Semantics: MatchElementEvaluation</h1>
      <p>The syntax-directed operation MatchElementEvaluation takes argument _matchable_ (an ECMAScript language value), _cacheGroup_ (a %WeakMap%) and _counter_ (a Record) and returns either a normal completion containing a Boolean or an abrupt completion. It is defined piecewise over the following productions:</p>
      <emu-grammar>
        MatchRestElement : `...` MatchPattern?
      </emu-grammar>
      <emu-alg>
        1. If MatchPattern is not present, return *true*.
        1. Let _iteratorRecord_ be ? MatchCachedGetIterator(_cacheGroup_, _matchable_).
        1. Let _A_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. Repeat,
          1. Let _next_ be ? MatchCachedIteratorStep(_cacheGroup_, _iteratorRecord_).
          1. If _iteratorRecord_.[[Matched]] is *false*, then
            1. Return ? MatchPatternMatches of MatchPattern with arguments _A_ and _cacheGroup_.
          1. Perform ! CreateDataPropertyOrThrow(A, ! ToString(ùîΩ(n)), _next_.[[Value]]).
          1. Set _n_ to _n_ + 1.
      </emu-alg>
      <emu-grammar>
        MatchElementList : MatchElisionElement
      </emu-grammar>
      <emu-alg>
        1. Return ? MatchElementEvaluation of MatchElisionElement with arguments _matchable_, _cacheGroup_, and _counter_.
      </emu-alg>
      <emu-grammar>
        MatchElementList : MatchElementList `,` MatchElisionElement
      </emu-grammar>
      <emu-alg>
        1. Let _result_ be ? MatchElementEvaluation of MatchElementList with arguments _matchable_, _cacheGroup_, and _counter_.
        1. If _result_ is *false*, return *false*.
        1. Return ? MatchElementEvaluation of MatchElisionElement with arguments _matchable_, _cacheGroup_, and _counter_.
      </emu-alg>
      <emu-grammar>
        MatchElisionElement : Elision? MatchPattern
      </emu-grammar>
      <emu-alg>
        1. If Elision is present, then
          1. Let _result_ be ? MatchElementEvaluation of Elision with arguments _matchable_, _cacheGroup_, and _counter_.
          1. If _result_ is *false*, return *false*.
        1. Let _value_ be ? MatchCachedGetIteratorNthItem(_cacheGroup_, _matchable_, _counter_.[[LastIndex]]).
        1. If _value_.[[Matched]] is *false*, return *false*.
        1. Let _result2_ be ? MatchPatternMatches of MatchPattern with arguments _value_.[[Value]] and _cacheGroup_.
        1. If _result2_ is *false*, return *false*.
        1. Set _counter_.[[LastIndex]] to _counter_.[[LastIndex]] + 1.
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        Elision : `,`
      </emu-grammar>
      <emu-alg>
        1. Let _result_ be ? MatchCachedGetIteratorNthItem(_cacheGroup_, _matchable_, _counter_.[[LastIndex]]).
        1. If _result_.[[Matched]] is *false*, return *false*.
        1. Set _counter_.[[LastIndex]] to _counter_.[[LastIndex]] + 1.
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        Elision : Elision `,`
      </emu-grammar>
      <emu-alg>
        1. Let _result_ be ? MatchElementEvaluation of Elision with arguments _matchable_, _cacheGroup_, and _counter_.
        1. If _result_ is *false*, return *false*.
        1. Let _result2_ be ? MatchCachedGetIteratorNthItem(_cacheGroup_, _matchable_, _counter_.[[LastIndex]]).
        1. If _result2_.[[Matched]] is *false*, return *false*.
        1. Set _counter_.[[LastIndex]] to _counter_.[[LastIndex]] + 1.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-record">
      <h1>Match Records</h1>
      <p>A Match Record is a Record value used to represent the match result of the match clause.</p>
      <p>Match Record have the fields listed in Table 1.</p>
      <emu-table>
        <emu-caption>Table 1</emu-caption>
        <table>
          <tr><th>Field Name</th><th>Value</th><th>Meaning</th></tr>
          <tr><td>[[Matched]]</td><td>a Boolean</td><td>If the match clause matched.</td></tr>
          <tr><td>[[Value]]</td><td>an ECMAScript language value or unused</td><td>The matched value.</td></tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-custom-matcher" type="abstract operation">
      <h1>
        InvokeCustomMatcher (
          _val_: an ECMAScript language value,
          _matchable_: an ECMAScript language value,
        ): either a normal completion containing an ECMAScript language value or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If Type(_val_) is not Object, return SameValue(_val_, _matchable_).
        1. Let _matcher_ be ? Get(_val_, @@matcher).
        1. If IsCallable(_matcher_) is *false*, throw a *TypeError* exception.
        1. Let _result_ be ? Call(_matcher_, _val_, ¬´ _matchable_ ¬ª).
        1. If Type(_result_) is not Object, throw a *TypeError* exception.
        1. Let _matched_ be ToBoolean(? Get(_result_, *"matched"*)).
        1. If _matched_ is *false*, return *false*.
        1. Return ? Get(_result_, *"value"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-regex-named-capture-group-binding" type="abstract operation">
      <h1>
        RegularExpressionNamedCaptureGroupBindingInitialization (
          _regexMatchResult_: an Array,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _groups_ be ! Get(_regexMatchResult_, *"groups"*).
        1. If _groups_ is *undefined*, return.
        1. Let _bindings_ be ! GetOwnPropertyKeys(_groups_, ~String~).
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _matchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Set the running execution context's LexicalEnvironment to _matchEnv_.
        1. For each element _name_ of _bindings_, do
          1. Perform ! _matchEnv_.CreateImmutableBinding(_name_, *true*).
          1. Perform ! _matchEnv_.InitializeBinding(_name_, ! Get(_groups_, _name_)).
      </emu-alg>
      <emu-note>
        The object _regexMatchResult_ that is used in this Abstract Operation is not accessible from user code. An implementation may choose to avoid the actual creation of the object.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-get-match-cache" type="abstract operation">
      <h1>
        GetMatchCache (
          _cacheGroup_: a WeakMap,
          _object_: an ECMAScript language value,
        ): an ECMAScript language value
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If ! Call(%WeakMap.prototype.has%, _cacheGroup_, ¬´ _object_ ¬ª) is *true*, then
          1. Return ! Call(%WeakMap.prototype.get%, _cacheGroup_, ¬´ _object_ ¬ª).
        1. Let _cache_ be OrdinaryObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, "Has", ! Construct(%Set%, *undefined*, a new Empty List)).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, "Get", ! Construct(%Map%, *undefined*, a new Empty List)).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, "Iterator", *undefined*).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, "IteratedItems", ! ArrayCreate(0)).
        1. Perform ! Call(%WeakMap.prototype.set%, _cacheGroup_, ¬´ _object_, _cache_ ¬ª).
        1. Return _cache_.
      </emu-alg>
      <emu-note>
        The object _cache_ and all of its data properties are not accessible from user code. An implementation may choose to avoid the actual creation of the object.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-match-cached-has-property" type="abstract operation">
      <h1>
        MatchCachedHasProperty (
          _cacheGroup_: a WeakMap,
          _object_: an ECMAScript language value,
          _propertyName_: a property key,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _cache_ be ! Get(GetMatchCache(_cacheGroup_, _object_), *"Has"*).
        1. Let _cachedResult_ be ! Call(%WeakMap.prototype.get%, _cache_, ¬´ _propertyName_ ¬ª).
        1. If Type(_cachedResult_) is Boolean, return _cachedResult_.
        1. Let _result_ be ? HasProperty(_object_, _propertyName_).
        1. Perform ! Call(%WeakMap.prototype.set%, _cache_, ¬´ _propertyName_, _result_ ¬ª).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-cached-get" type="abstract operation">
      <h1>
        MatchCachedGet (
          _cacheGroup_: a WeakMap,
          _object_: an ECMAScript language value,
          _propertyName_: a property key,
        ): either a normal completion containing an ECMAScript language value or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _cache_ be ! Get(GetMatchCache(_cacheGroup_, _object_), "Get").
        1. Let _hasCache_ be ! Call(%Map.prototype.has%, _cache_, ¬´ _propertyName_ ¬ª).
        1. If _hasCache_ is *true*, return ! Call(%Map.prototype.get%, _cache_, ¬´ _propertyName_ ¬ª).
        1. Let _result_ be ? Get(_object_, _propertyName_).
        1. Perform ! Call(%Map.prototype.set%, _cache_, ¬´ _propertyName_, _result_ ¬ª).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-cached-is-iterable" type="abstract operation">
      <h1>
        MatchCachedIsIterable (
          _cacheGroup_: a WeakMap,
          _object_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _iter_ be ? MatchCachedGet(_cacheGroup_, _object_, @@iterator).
        1. If Type(_iter_) is not Function, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-cached-get-iterator" type="abstract operation">
      <h1>
        MatchCachedGetIterator (
          _cacheGroup_: a WeakMap,
          _object_: an ECMAScript language value,
        ): either a normal completion containing an Iterator Record or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _cache_ be GetMatchCache(_cacheGroup_, _object_).
        1. Let _iter_ be ! Get(_cache_, "Iterator").
        1. If _iter_ is not *undefined*, return _iter_.[[CachedIterator]].
        1. Let _f_ be ? MatchCachedGet(_cacheGroup_, _object_, @@iterator).
        1. Set _iter_ to OrdinaryObjectCreate(*null*, ¬´ [[CachedIterator]] ¬ª).
        1. Set _iter_.[[CachedIterator]] to ? GetIterator(_object_, ~sync~, _f_).
        1. Perform ! Set(_cache_, "Iterator", _iter_, *true*).
        1. Perform ! Call(%Set.prototype.add%, ! Get(_cacheGroup_, "IteratorToClose"), ¬´ _iter ¬ª).
        1. Return _iter_.[[CachedIterator]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-cached-iterator-step" type="abstract operation">
      <h1>
        MatchCachedIteratorStep (
          _cacheGroup_: a WeakMap,
          _iterator_: an Iterator Record,
        ): either a normal completion containing a Match Record or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _iterator_.[[Done]] is *true*, return Match Record { [[Matched]]: *false*, [[Value]]: ~unused~ }.
        1. Let _cache_ be GetMatchCache(_cacheGroup_, _iterator_).
        1. Let _cachedItems_ be ! Get(_cache_, "IteratedItems").
        1. Let _iterResult_ be Completion(IteratorStep(_iterator_)).
        1. If _iterResult_ is an abrupt completion, set _iterator_.[[Done]] to *true*.
        1. ReturnIfAbrupt(_iterResult_).
        1. If _iterResult_ is *false*, then
          1. Set _iterator_.[[Done]] to *true*.
          1. Return Match Record { [[Matched]]: *false*, [[Value]]: ~unused~ }.
        1. Let _value_ be Completion(IteratorValue(_iterResult_)).
        1. If _value_ is an abrupt completion, set _iterator_.[[Done]] to *true*.
        1. ReturnIfAbrupt(_value_).
        1. Perform ! Call(%Array.prototype.push%, _cachedItems_, ¬´ _value_ ¬ª).
        1. Return Match Record { [[Matched]]: *true*, [[Value]]: _value_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-cached-get-iterator-nth-item" type="abstract operation">
      <h1>
        MatchCachedGetIteratorNthItem (
          _cacheGroup_: a WeakMap,
          _iterator_: an Iterator Record,
          _n_: a Number,
        ): either a normal completion containing a Match Record or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _cache_ be GetMatchCache(_cacheGroup_, _iterator_).
        1. Let _cachedItems_ be ! Get(_cache_, "IteratedItems").
        1. Let _nthItem_ be ! _cachedItems_.[[GetOwnProperty]](_n_).
        1. If _nthItem_ is not *undefined*, return Match Record { [[Matched]]: *true*, [[Value]]: _nthItem_.[[Value]] }.
        1. If _iterator_.[[Done]] is *true*, return Match Record { [[Matched]]: *false*, [[Value]]: ~unused~ }.
        1. Return ? MatchCachedIteratorStep(_cacheGroup_, _iterator_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-iterator-length-match" type="abstract operation">
      <h1>
        MatchIteratorLengthMatch (
          _cacheGroup_: a WeakMap,
          _matchable_: an ECMAScript language value,
          _lastIndex_: a Number,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _iterator_ be ? MatchCachedGetIterator(_cacheGroup_, _matchable_).
        1. Let _cache_ be GetMatchCache(_cacheGroup_, _iterator_).
        1. Let _cachedItems_ be ! Get(_cache_, "IteratedItems").
        1. Let _length_ be ! Get(_cachedItems_, "length").
        1. If _lastIndex_ &gt; -1, then
          1. If _length_ &gt; _lastIndex_, return *false*.
          1. If _iterator_.[[Done]] is *true*, then
            1. If _length_ = _lastIndex_, return *true*.
            1. Return *false*.
        1. Let _iterResult_ be ? MatchCachedGetIteratorNthItem(_cacheGroup_, _iterator_, _lastIndex_ + 1).
        1. If _iterResult_.[[Matched]] is *true*, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-close-iterators" type="abstract operation">
      <h1>
        CloseIterators (
          _iterators_: a List of Iterator Records
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _errors_ be a new empty List.
        1. For each element _iter_ of _iterators_, do
          1. If _iter_.[[Done]] is *false*, then
            1. Let _completion_ be Completion(IteratorClose(_iter_, NormalCompletion(*undefined*))).
            1. If _completion_ is an abrupt completion, append _completion_.[[Value]] to _errors_.
        1. If _errors_ is not empty, then
          1. If length of _errors_ is 1, return ThrowCompletion(_errors_[0]).
          1. Let _error_ be a newly created AggregateError object.
          1. Perform ! DefinePropertyOrThrow(error, "errors", PropertyDescriptor { [[Configurable]]: true, [[Enumerable]]: false, [[Writable]]: true, [[Value]]: CreateArrayFromList(errors) }).
          1. Return ThrowCompletion(error).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-add-match-binding" type="abstract operation">
      <h1>
        AddMatchBinding (
          _name_: a String,
          _value_: an ECMAScript language value
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _matchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Set the running execution context's LexicalEnvironment to _matchEnv_.
        1. Perform ! _matchEnv_.CreateImmutableBinding(_name_, *true*).
        1. Perform ! _matchEnv_.InitializeBinding(_name_, _value_).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
<emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

<emu-clause id="sec-fundamental-objects">
  <h1>Fundamental Objects</h1>

  <emu-clause id="sec-object-objects">
    <h1>Object Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-object-constructor">
      <h1>Properties of the Object Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause id="sec-object-@@matcher">
        <h1>Object [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is an Object.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-objects">
    <h1>Function Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-function-constructor">
      <h1>Properties of the Function Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause id="sec-function-@@matcher">
        <h1>Function [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Function.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If IsCallable(_value_) is *false*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-boolean-objects">
    <h1>Boolean Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-constructor">
      <h1>Properties of the Boolean Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause id="sec-boolean-@@matcher">
        <h1>Boolean [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Boolean.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(thisBooleanValue(_value_)).
          1. If _result_ is an abrupt completion, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-symbol-objects">
    <h1>Symbol Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-constructor">
      <h1>Properties of the Symbol Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause id="sec-symbol-@@matcher">
        <h1>Symbol [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Symbol.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(thisSymbolValue(_value_)).
          1. If _result_ is an abrupt completion, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-error-objects">
    <h1>Error Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-error-constructor">
      <h1>Properties of the Error Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="error-@@matcher">
        <h1>Error [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is an Error.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have an [[ErrorData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
  <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

  <emu-clause id="sec-nativeerror-object-structure">
      <h1>_NativeError_ Object Structure</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-constructors">
        <h1>Properties of the _NativeError_ Constructors</h1>

        <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

        <emu-clause sec id="nativeerror-@@matcher">
        <h1>_NativeError_ [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a <code><var>NativeError</var></code>.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have an [[ErrorData]] internal slot, return CreateMatchResultObject(*false*).
          1. NOTE: TODO: use either ? Get(_value_, *"name"*), or ? Get(_value_, *"constructor"*), or check if [[Prototype]] is %_NativeError_.prototype%, or add a _NativeError_ slot.
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-aggregate-error-objects">
    <h1>AggregateError Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-aggregate-error-constructor">
      <h1>Properties of the Error Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="aggregate-error-@@matcher">
        <h1>Error [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is an AggregateError.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have an [[ErrorData]] internal slot, return CreateMatchResultObject(*false*).
          1. NOTE: TODO: use either ? Get(_value_, *"name"*), or ? Get(_value_, *"constructor"*), or check if [[Prototype]] is %AggregateError.prototype%, or add a _NativeError_ slot.
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>

  <emu-clause id="sec-number-objects">
    <h1>Number Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-number-constructor">
      <h1>Properties of the Number Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause id="sec-number-@@matcher">
        <h1>Number [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Number.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(thisNumberValue(_value_)).
          1. If _result_ is an abrupt completion, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bigint-objects">
    <h1>BigInt Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-constructor">
      <h1>Properties of the BigInt Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause id="sec-bigint-@@matcher">
        <h1>BigInt [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a BigInt.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(thisBigIntValue(_value_)).
          1. If _result_ is an abrupt completion, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

  <emu-clause id="sec-date-objects">
    <h1>Date Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-date-constructor">
      <h1>Properties of the Date Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="date-@@matcher">
        <h1>Date [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Date.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[DateValue]] internal slot, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-text-processing">
  <h1>Text Processing</h1>

  <emu-clause id="sec-string-objects">
    <h1>String Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-string-constructor">
      <h1>Properties of the String Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="string-@@matcher">
        <h1>String [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a String.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(thisStringValue(_value_)).
          1. If _result_ is an abrupt completion, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-regexp-regular-expression-objects">
    <h1>RegExp (Regular Expression) Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-constructor">
      <h1>Properties of the RegExp Constructor</h1>

      <emu-clause sec id="regexp-@@matcher">
        <h1>RegExp [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a RegExp.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(IsRegExp(_value_)).
          1. If _result_ is an abrupt completion, or if _result_.[[Value]] is *false*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-prototype-object">
      <h1>Properties of the RegExp Prototype Object</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="regexp-prototype-@@matcher">
        <h1>RegExp.prototype [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value matches the RegExp.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).
          1. Let _S_ be ? ToString(_value_).
          1. Let _result_ be ? RegExpBuiltinExec(_R_, _matchable_).
          1. If _result_ is *null*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-indexed-collections">
  <h1>Indexed Collections</h1>

  <emu-clause id="sec-array-objects">
    <h1>Array Objects</h1>

    <emu-clause id="sec-properties-of-the-array-constructor">
      <h1>Properties of the Array Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="array-@@matcher">
        <h1>Array [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is an Array.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(IsArray(_value_)).
          1. If _result_ is an abrupt completion, or if _result_.[[Value]] is *false*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-objects">
    <h1>TypedArray Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-typedarray-constructors">
      <h1>Properties of the _TypedArray_ Constructors</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="typedarray-@@matcher">
        <h1>_TypedArray_ [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a _TypedArray_.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, return CreateMatchResultObject(*false*).
          1. If _value_ does not have a [[TypedArrayName]] internal slot, return CreateMatchResultObject(*false*).
          1. If _value_.[[TypedArrayName]] is not _TypedArray_, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
        <emu-note type="editor">TODO: probably i need to convert _TypedArray_ into a string to be able to do the comparison to the internal slot.</emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-keyed-collections" oldids="sec-keyed-collection">
  <h1>Keyed Collections</h1>

  <emu-clause id="sec-map-objects">
    <h1>Map Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-map-constructor">
      <h1>Properties of the Map Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="map-@@matcher">
        <h1>Map [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Map.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[MapData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-set-objects">
    <h1>Set Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-set-constructor">
      <h1>Properties of the Set Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="set-@@matcher">
        <h1>Set [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Set.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[SetData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakmap-objects">
    <h1>WeakMap Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-constructor">
      <h1>Properties of the WeakMap Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="weakmap-@@matcher">
        <h1>WeakMap [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a WeakMap.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[WeakMapData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakset-objects">
    <h1>WeakSet Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-constructor">
      <h1>Properties of the WeakSet Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="weakset-@@matcher">
        <h1>WeakSet [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a WeakSet.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[WeakSetData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-structured-data">
  <h1>Structured Data</h1>

  <emu-clause id="sec-arraybuffer-objects">
    <h1>ArrayBuffer Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-constructor">
      <h1>Properties of the ArrayBuffer Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="arraybuffer-@@matcher">
        <h1>ArrayBuffer [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is an ArrayBuffer.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have an [[ArrayBufferData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-objects">
    <h1>SharedArrayBuffer Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-constructor">
      <h1>Properties of the SharedArrayBuffer Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="sharedarraybuffer-@@matcher">
        <h1>SharedArrayBuffer [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a SharedArrayBuffer.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have an [[ArrayBufferData]] internal slot, return CreateMatchResultObject(*false*).
          1. If IsSharedArrayBuffer(_value_) is *false*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-objects">
    <h1>DataView Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-constructor">
      <h1>Properties of the DataView Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="dataview-@@matcher">
        <h1>DataView [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a DataView.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[DataView]] internal slot, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-managing-memory">
  <h1>Managing Memory</h1>

  <emu-clause id="sec-weak-ref-objects">
    <h1>WeakRef Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-weak-ref-constructor">
      <h1>Properties of the WeakRef Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="weak-ref-@@matcher">
        <h1>WeakRef [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a WeakRef.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[WeakRefTarget]] internal slot, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-finalization-registry-objects">
    <h1>FinalizationRegistry Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-finalization-registry-constructor">
      <h1>Properties of the FinalizationRegistry Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="finalization-registry-@@matcher">
        <h1>FinalizationRegistry [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a FinalizationRegistry.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[Cells]] internal slot, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>Control Abstraction Objects</h1>

  <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

  <emu-clause id="sec-promise-objects">
    <h1>Promise Objects</h1>

    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
    <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

    <emu-clause id="sec-properties-of-the-promise-constructor">
      <h1>Properties of the Promise Constructor</h1>

      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>
      <emu-clause id="sec-placeholder"><h1>Placeholder to ensure correct clause numbering</h1></emu-clause>

      <emu-clause sec id="promise-@@matcher">
        <h1>Promise [ @@matcher ] ( _value_ )</h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Promise.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If IsPromise(_value_) is *false*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
        <emu-note type="editor">
          TODO: decide if we want to loosen this to accept thenables, breaking with the precedent set here by the rest of the built-in matchers.
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-todo">
  <h1>TODO</h1>

  <emu-clause id="todo-constructors">
    <h1>Confirm we do not want matchers for these constructors</h1>
    <emu-alg>
      1. Iterator/AsyncIterator (probably when Iterator Helpers advances).
      1. Record/Tuple (definintely when R&T advances).
      1. GeneratorFunction/AsyncFunction/AsyncGeneratorFunction (maybe).
      1. Generator/AsyncGenerator (probably not).
      1. Proxy (definitely not).
    </emu-alg>
  </emu-clause>

  <emu-clause id="todo-boxed-prims">
    <h1>Add builtin matchers on the prototype for relevant boxed primitives, matching hardcoded primitive matching</h1>
    <emu-alg>
      1. Boolean.
      1. String.
      1. Number.
      1. Symbol.
      1. BigInt.
    </emu-alg>
  </emu-clause>
</emu-clause>
