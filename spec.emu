<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Pattern Matching
stage: 1
contributors:
  - Daniel Rosenwasser
  - Jack Works
  - Jordan Harband
  - Mark Cohen
  - Ross Kirsling
  - Tab Atkins
</pre>

<emu-clause id="sec-ecmascript-data-types-and-values" aoid="Type" number="6">
  <h1>ECMAScript Data Types and Values</h1>
  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript Language Types</h1>

    <emu-clause id="sec-ecmascript-language-types-symbol-type" number="5">
      <h1>The Symbol Type</h1>
      <emu-clause id="sec-well-known-symbols">
        <h1>Well-Known Symbols</h1>
        <emu-table id="table-1" caption="Well-known Symbols">
          <table>
            <tbody>
            <tr>
              <th>
                Specification Name
              </th>
              <th>
                [[Description]]
              </th>
              <th>
                Value and Purpose
              </th>
            </tr>
            <tr>
              <td>
                <ins><dfn>@@matcher</dfn></ins>
              </td>
              <td>
                <ins>`"Symbol.matcher"`</ins>
              </td>
              <td>
                <ins>A method that performs custom pattern matching semantics. Called by the semantics of the `match` expression.</ins>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-intrinsic-matcher">
  <h1>Misc</h1>

  <emu-clause id="sec-create-match-record" type="abstract operation">
    <h1><ins>
      CreateMatchRecord (
        _matched_: a Boolean,
        optional _value_: an ECMAScript language value,
      ): a Match Record
    </ins></h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. If _matched_ is *true*, then
        1. Assert: _value_ is present.
        1. Return Match Record { [[Matched]]: *true*, [[Value]]: _value_ }.
      1. Assert: _value_ is not present.
      1. Return Match Record { [[Matched]]: _matched_, [[Value]]: ~unused~ }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-create-match-result" type="abstract operation">
    <h1><ins>
      CreateMatchResultObject (
        _matched_: a Boolean,
        optional _value_: an ECMAScript language value,
      ): an Object that conforms to the MatchResult interface
    </ins></h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).
      1. Perform ! CreateDataPropertyOrThrow(_obj_, *"matched"*, _matched_).
      1. If _matched_ is *true*, then
        1. Assert: _value_ is present.
        1. Perform ! CreateDataPropertyOrThrow(_obj_, *"value"*, _value_).
      1. Else,
        1. Assert: _value_ is not present.
      1. Return _obj_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-match-constructor-instance" type="abstract operation">
    <h1><ins>
      MatchConstructorInstance (
        _value_: an Object,
        _target_: an ECMAScript language value,
        optional _intrinsicName_: a String,
      ): either a normal completion containing an Object that conforms to the MatchResult interface, or an abrupt completion
    </ins></h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. Let _O_ be _value_.
      1. Repeat,
        1. Let _C_ be ? Get(_O_, *"constructor"*).
        1. If _intrinsicName_ is present, and _C_ matches the intrinsic described in <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref> by _intrinsicName_ in any realm, then
          1. Return CreateMatchResultObject(*true*, _value_).
        1. If IsConstructor(_target_) is *true*, and SameValue(_C_, _target_) is *true*, then
          1. Return CreateMatchResultObject(*true*, _value_).
        1. Set _O_ to ? _O_.[[GetPrototypeOf]]().
        1. If _O_ is *null*, return CreateMatchResultObject(*false*).
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions" number="13">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-match-expression" number="5">
    <h1><ins>Match Expression</ins></h1>
    <emu-clause id="sec-match-expression-syntax">
      <h1>Syntax</h1>
      <emu-note type="editor">Work in progress.</emu-note>
      <emu-grammar type="definition">
        MatchExpression ::
          `match` [no LineTerminator here] `(` Expression `)` [no LineTerminator here] `{` MatchClauses? `}`

        MatchClauses :
          MatchClause
          MatchClauses MatchClause

        MatchClause :
          `when` `(` MatchPattern `)` `if` `(` Expression `)` `:` Expression
          `when` `(` MatchPattern `)` `:` Expression
          `if` `(` Expression `)` `:` Expression
          `default` `:` Expression

        MatchPattern :
          NearLiteralMatchPattern
          MemberExpressionMatchPattern
          ExtractorMatchPattern
          BindingIdentifierMatchPattern
          ArrayMatchPattern
          ObjectMatchPattern
          CombinedMatchPattern
          `(` MatchPattern `)`

        NearLiteralMatchPattern :
          `NaN`
          `+`? `Infinity`
          `-` `Infinity`
          `undefined`
          NullLiteral
          BooleanLiteral
          `+`? NumericLiteral
          `-` NumericLiteral
          StringLiteral
          RegularExpressionLiteral
          TemplateLiteral[~Tagged]

        MemberExpressionMatchPattern :
          IdentifierReference
          MemberExpressionPattern `.` IdentifierName

        ExtractorMatchPattern :
          RegularExpressionLiteral `(` ExtractorPatternList `)`
          MemberExpressionPattern `(` ExtractorPatternList `)`

        ExtractorPatternList :
          MatchPattern
          `...` MatchPattern
          ExtractorPatternList `,` MatchPattern
          ExtractorPatternList `,` `...` MatchPattern

        BindingIdentifierMatchPattern :
          `var` BindingIdentifier
          `let` BindingIdentifier
          `const` BindingIdentifier

        ArrayMatchPattern :
          `[` Elision? ArrayMatchPatternRestElement? `]`
          `[` ArrayMatchPatternElementList `]`
          `[` ArrayMatchPatternElementList `,` Elision? ArrayMatchPatternRestElement? `]`

        ObjectMatchPattern :
          `{` `}`
          `{` MatchRestProperty `}`
          `{` ObjectMatchPatternPropertyList `}`
          `{` ObjectMatchPatternPropertyList `,` MatchRestProperty? `}`

        CombinedMatchPattern:
          MatchPattern `or` MatchPattern
          MatchPattern `and` MatchPattern
          `not` MatchPattern

        ArrayMatchPatternElementList :
          ArrayMatchPatternElisionElement
          ArrayMatchPatternElementList `,` ArrayMatchPatternElisionElement

        ArrayMatchPatternElisionElement :
          Elision? MatchPattern

        ArrayMatchPatternRestElement :
          `...` MatchPattern?

        ObjectMatchPatternPropertyList :
          ObjectMatchPatternProperty
          ObjectMatchPatternPropertyList `,` ObjectMatchPatternProperty

        ObjectMatchPatternProperty :
          BindingIdentifier
          BindingIdentifierMatchPattern
          PropertyName `?`? `:` MatchPattern

        MatchRestProperty :
          `...` MatchPattern

      </emu-grammar>
    </emu-clause>
    <emu-clause id="sec-match-expression-early-errors">
      <h1><ins>Static Semantics: Early Errors</ins></h1>
      <emu-note type="editor">This section has not written in normative spec language yet.</emu-note>
      <emu-grammar>
        MatchClauses :
          MatchClause
          MatchClauses MatchClause
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if there are more than one `default` `:` clause.</li>
        <li>It is a Syntax Error if any other clauses follow the `default` `:` clause.</li>
      </ul>
      <emu-grammar>
        MatchPattern :
          CombinedMatchPattern
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if the combined match pattern has both `not`, `or` and `and` at the same level without a `()`. For example, `a or b and c` is an early error, `a or (b and c)` or `(a or b) and c` is okay.</li>
      </ul>
    </emu-clause>
    <emu-clause id="sec-match-expression-runtime-semantics">
      <h1><ins>Runtime Semantics: Evaluation</ins></h1>
      <emu-grammar>
        MatchExpression ::
          `match` `(` Expression `)` `{` MatchClauses? `}`
      </emu-grammar>
      <emu-alg>
        1. Let _matchableRef_ be ? Evaluation of |Expression|.
        1. Let _matchable_ be ? GetValue(_matchableRef_).
        1. If |MatchClauses| is not present, throw a *TypeError* exception.
        1. Let _cacheGroup_ be ! Construct(%Map%, a new empty List).
        1. Let _iterators_ be ! Construct(%Set%, a new empty List).
        1. Perform ! CreateDataPropertyOrThrow(_cacheGroup_, *"IteratorToClose"*, iterators).
        1. Let _result_ be Completion(MatchClausesEvaluation of |MatchClauses| with argument _matchable_ and _cacheGroup_).
        1. Let _iteratorRecords_ be a new empty List.
        1. For each element _iter_ of _iterators_.[[SetData]], do
          1. Append _iter_.[[CachedIterator]] to _iteratorRecords_.
        1. Perform ? CloseIterators(_iteratorRecords_).
        1. ReturnIfAbrupt(_result_).
        1. If _result_.[[Matched]] is *true*, return _result_.[[Value]].
        1. Throw a *TypeError* exception.
      </emu-alg>
      <emu-note>
        The object _cacheGroup_ is not accessible from user code. An implementation may choose to avoid the actual creation of the object.
      </emu-note>
    </emu-clause>
    <emu-clause id="sec-match-clauses-evaluation" type="sdo">
      <h1>
        Runtime Semantics: MatchClausesEvaluation (
          _matchable_: an ECMAScript language value,
          _cacheGroup_: a %Map%,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        MatchClauses : MatchClause
      </emu-grammar>
      <emu-alg>
        1. Return ? MatchClauseEvaluation of |MatchClause| with argument _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchClauses : MatchClauses MatchClause
      </emu-grammar>
      <emu-alg>
        1. Let _result_ be ? MatchClausesEvaluation of |MatchClauses| with argument _matchable_ and _cacheGroup_.
        1. If _result_.[[Matched]] is *true*, return _result_.
        1. Return ? MatchClauseEvaluation of |MatchClause| with argument _matchable_ and _cacheGroup_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-match-clause-evaluation" type="sdo">
      <h1>
        Runtime Semantics: MatchClauseEvaluation (
          _matchable_: an ECMAScript language value,
          _cacheGroup_: a %Map%,
        ): either a normal completion containing a Match Record or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        MatchClause : `when` `(` MatchPattern `)` `if` `(` Expression `)` `:` Expression
      </emu-grammar>
      <emu-alg>
        1. Let _closure_ be a new Abstract Closure with parameters () that captures _matchable_, _cacheGroup_, MatchPattern, the first |Expression|, and the second |Expression| and performs the following steps when called:
          1. Let _matches_ be ? MatchPatternMatches of |MatchPattern| with arguments _matchable_ and _cacheGroup_.
          1. If _matches_ is *false*, return CreateMatchRecord(*false*).
          1. Let _ifRef_ be ? Evaluation of the first |Expression|.
          1. Let _ifVal_ be ToBoolean(? GetValue(_ifRef_)).
          1. If _ifVal_ is *false*, return CreateMatchRecord(*false*).
          1. Let _exprRef_ be ? Evaluation of the second |Expression|.
          1. Let _exprVal_ be ? GetValue(_exprRef_).
          1. Return CreateMatchRecord(*true*, _exprVal_).
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _matchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Set the running execution context's LexicalEnvironment to _matchEnv_.
        1. Let _result_ be _closure_ ().
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return _result_.
      </emu-alg>
      <emu-grammar>
        MatchClause : `when` `(` MatchPattern `)` `:` Expression
      </emu-grammar>
      <emu-alg>
        1. Let _closure_ be a new Abstract Closure with parameters () that captures _matchable_, _cacheGroup_, MatchPattern, and |Expression| and performs the following steps when called:
          1. Let _matches_ be ? MatchPatternMatches of |MatchPattern| with arguments _matchable_ and _cacheGroup_.
          1. If _matches_ is *false*, return CreateMatchRecord(*false*).
          1. Let _exprRef_ be ? Evaluation of |Expression|.
          1. Let _exprVal_ be ? GetValue(_exprRef_).
          1. Return CreateMatchRecord(*true*, _exprVal_).
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _matchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Set the running execution context's LexicalEnvironment to _matchEnv_.
        1. Let _result_ be _closure_ ().
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return _result_.
      </emu-alg>
      <emu-grammar>
        MatchClause : `if` `(` Expression `)` `:` Expression
      </emu-grammar>
      <emu-alg>
        1. Let _ifRef_ be ? Evaluation of the first |Expression|.
        1. Let _ifVal_ be ToBoolean(? GetValue(_ifRef_)).
        1. If _ifVal_ is *false*, return CreateMatchRecord(*false*).
        1. Let _exprRef_ be ? Evaluation of the second |Expression|.
        1. Let _exprVal_ be ? GetValue(_exprRef_).
        1. Return CreateMatchRecord(*true*, _exprVal_).
      </emu-alg>
      <emu-grammar>
        MatchClause : `default` `:` Expression
      </emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |Expression|.
        1. Let _exprVal_ be ? GetValue(_exprRef_).
        1. Return CreateMatchRecord(*true*, _exprVal_).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-match-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: MatchPatternMatches (
          _matchable_: an ECMAScript language value,
          _cacheGroup_: a %Map%,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        MatchPattern : CombinedMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? CombinedMatchPatternMatches of |CombinedMatchPattern| with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : InterpolationPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? InterpolationPatternMatches of |InterpolationPattern| with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : IdentifierMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _identifier_ be the |Identifier| that is covered by |IdentifierMatchPattern|.
        1. Let _name_ be the StringValue of _identifier_.
        1. If _name_ is *"Infinity"*, return SameValue(_matchable_, *Infinity*).
        1. If _name_ is *"undefined"*, return SameValue(_matchable_, *undefined*).
        1. If _name_ is *"NaN"*, return SameValue(_matchable_, *NaN*).
        1. Perform AddMatchBinding(_name_[0], _matchable_).
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        MatchPattern : NearLiteralMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? NearLiteralMatchPatternMatches of |NearLiteralMatchPattern| with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : ObjectMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? DestructuringMatchPatternMatches of |ObjectMatchPattern| with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : ArrayMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? DestructuringMatchPatternMatches of |ArrayMatchPattern| with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : `(` MatchPattern `)`
      </emu-grammar>
      <emu-alg>
        1. Return ? MatchPatternMatches of |MatchPattern| with argument _matchable_ and _cacheGroup_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-combined-match-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: CombinedMatchPatternMatches (
          _matchable_: an ECMAScript language value,
          _cacheGroup_: a %Map%,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        CombinedMatchPattern : MatchPattern `or` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _leftMatches_ be ? MatchPatternMatches of the first |MatchPattern| with arguments _matchable_ and _cacheGroup_.
        1. If _leftMatches_ is *true*, return *true*.
        1. Return ? MatchPatternMatches of the second |MatchPattern| with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        CombinedMatchPattern : MatchPattern `and` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _leftMatches_ be ? MatchPatternMatches of the first |MatchPattern| with arguments _matchable_ and _cacheGroup_.
        1. If _leftMatches_ is *false*, return *false*.
        1. Return ? MatchPatternMatches of the second |MatchPattern| with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-interpolation-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: InterpolationPatternMatches (
          _matchable_: an ECMAScript language value,
          _cacheGroup_: a %Map%,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        InterpolationPattern : `${` Expression `}`
      </emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |Expression|.
        1. Let _exprVal_ be ? GetValue(_exprRef_).
        1. Let _result_ be ? InvokeCustomMatcher(_exprVal_, _matchable_).
        1. If _result_ is ~not-matched~, return *false*.
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        InterpolationPattern : `${` Expression `}` `with` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |Expression|.
        1. Let _exprVal_ be ? GetValue(_exprRef_).
        1. Let _result_ be ? InvokeCustomMatcher(_exprVal_, _matchable_).
        1. If _result_ is ~not-matched~, return *false*.
        1. Return ? MatchPatternMatches of |MatchPattern| with arguments _result_ and _cacheGroup_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-near-literal-match-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: NearLiteralMatchPatternMatches (
          _matchable_: an ECMAScript language value,
          _cacheGroup_: a %Map%,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        NearLiteralMatchPattern : NullLiteral
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, *null*).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : BooleanLiteral
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, ? Evaluation of |BooleanLiteral|).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : NumericLiteral
      </emu-grammar>
      <emu-alg>
        1. Let _numeric_ be ? Evaluation of |NumericLiteral|.
        1. NOTE: TODO: *-0*<sub>ùîΩ</sub> is handled already, but when there is no explicit `+` sign, the next line should use SameValueZero.
        1. Return SameValue(_matchable_, _numeric_).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, ? Evaluation of |StringLiteral|).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : RegularExpressionLiteral `with` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _regexp_ be ? Evaluation of |RegularExpressionLiteral|.
        1. Let _result_ be ? RegExpBuiltinExec(_regexp_, ? ToString(_matchable_)).
        1. If _result_ is *null*, return *false*.
        1. Perform RegularExpressionNamedCaptureGroupBindingInitialization(_result_).
        1. Return ? MatchPatternMatches of |MatchPattern| with arguments _result_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : RegularExpressionLiteral
      </emu-grammar>
      <emu-alg>
        1. Let _regexp_ be ? Evaluation of |RegularExpressionLiteral|.
        1. Let _result_ be ? RegExpBuiltinExec(_regexp_, ? ToString(_matchable_)).
        1. If _result_ is *null*, return *false*.
        1. Perform RegularExpressionNamedCaptureGroupBindingInitialization(_result_).
        1. Return *true*.
      </emu-alg>
      <emu-note>
        The object that returned from RegExpBuiltinExec in this Abstract Operation is not accessible from user code. An implementation may choose to avoid the actual creation of the object.
      </emu-note>
      <emu-grammar>
        NearLiteralMatchPattern : TemplateLiteral[~Tagged]
      </emu-grammar>
      <emu-alg>
        1. Let _strRef_ be ? Evaluation of |TemplateLiteral|.
        1. Let _str_ be ? GetValue(_strRef_).
        1. Return SameValue(_matchable_, _str_).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : `+` NumericLiteral
      </emu-grammar>
      <emu-alg>
        1. Let _num_ be ? Evaluation of |NumericLiteral|.
        1. Return SameValueZero(_matchable_, _num_).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : `-` NumericLiteral
      </emu-grammar>
      <emu-alg>
        1. Let _num_ be ? Evaluation of |NumericLiteral|.
        1. Return SameValueZero(_matchable_, -_num_).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : `+` `Infinity`
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, *Infinity*).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : `-` `Infinity`
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, *-Infinity*).
      </emu-alg>
      <emu-grammar>
        NearLiteralMatchPattern : `+` `NaN`
        NearLiteralMatchPattern : `-` `NaN`
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_matchable_, *NaN*).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-destructuring-match-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: DestructuringMatchPatternMatches (
          _matchable_: an ECMAScript language value,
          _cacheGroup_: a %Map%,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ObjectMatchPattern : `{` `}`
      </emu-grammar>
      <emu-alg>
        1. If Type(_matchable_) is not Object, return *false*.
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        ObjectMatchPattern : `{` MatchRestProperty `}`
      </emu-grammar>
      <emu-alg>
        1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Let _excludedNames_ be a new empty List.
        1. Perform ? CopyDataProperties(_restObj_, _matchable_, _excludedNames_).
        1. Perform ? MatchRestPropertyEvaluation of |MatchRestProperty| with arguments _restObj_, _cacheGroup_ and _excludedNames_.
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        ObjectMatchPattern : `{` ObjectMatchPatternPropertyList `}`
      </emu-grammar>
      <emu-alg>
        1. If Type(_matchable_) is not Object, return *false*.
        1. Let _result_ be ? ObjectMatchPatternPropertyEvaluation of |ObjectMatchPatternPropertyList| with arguments _matchable_ and _cacheGroup_.
        1. If _result_ is a List, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        ObjectMatchPattern : `{` ObjectMatchPatternPropertyList `,` MatchRestProperty? `}`
      </emu-grammar>
      <emu-alg>
        1. If Type(_matchable_) is not Object, return *false*.
        1. Let _result_ be ? ObjectMatchPatternPropertyEvaluation of |ObjectMatchPatternPropertyList| with arguments _matchable_ and _cacheGroup_.
        1. If _result_ is ~not-matched~, return *false*.
        1. Assert: _result_ is a List.
        1. Let _excludedNames_ be _result_.
        1. If |MatchRestProperty| is present, then
          1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ? CopyDataProperties(_restObj_, _matchable_, _excludedNames_).
          1. Return ? MatchRestPropertyEvaluation of |MatchRestProperty| with arguments _restObj_, _cacheGroup_ and _excludedNames_.
        1. Return _result_.
      </emu-alg>
      <emu-grammar>
        ArrayMatchPattern : `[` Elision? ArrayMatchPatternRestElement? `]`
      </emu-grammar>
      <emu-alg>
        1. If ? MatchCachedIsIterable(_cacheGroup_, _matchable_) is *false*, return *false*.
        1. Let _index_ be Record { [[LastIndex]]: -1 }.
        1. If |Elision| is present, then
          1. Let _result_ be ? MatchElementEvaluation of |Elision| with arguments _matchable_, _cacheGroup_ and _index_.
          1. If _result_ is *false*, return *false*.
        1. If |ArrayMatchPatternRestElement| is present, then
          1. Return ? MatchElementEvaluation of |ArrayMatchPatternRestElement| with arguments _matchable_, _cacheGroup_ and _index_.
        1. Return ? MatchIteratorLengthMatch(_cacheGroup_, _matchable_, index.[[LastIndex]]).
      </emu-alg>
      <emu-grammar>
        ArrayMatchPattern : `[` ArrayMatchPatternElementList `]`
      </emu-grammar>
      <emu-alg>
        1. If ? MatchCachedIsIterable(_cacheGroup_, _matchable_) is *false*, return *false*.
        1. Let _index_ be Record { [[LastIndex]]: -1 }.
        1. Let _result_ be ? MatchElementEvaluation of |ArrayMatchPatternElementList| with arguments _matchable_, _cacheGroup_ and _index_.
        1. If _result_ is *false*, return *false*.
        1. Return ? MatchIteratorLengthMatch(_cacheGroup_, _matchable_, index.[[LastIndex]]).
      </emu-alg>
      <emu-grammar>
        ArrayMatchPattern : `[` ArrayMatchPatternElementList `,` Elision? ArrayMatchPatternRestElement? `]`
      </emu-grammar>
      <emu-alg>
        1. If ? MatchCachedIsIterable(_cacheGroup_, _matchable_) is *false*, return *false*.
        1. Let _index_ be Record { [[LastIndex]]: -1 }.
        1. Let _result_ be ? MatchElementEvaluation of |ArrayMatchPatternElementList| with arguments _matchable_, _cacheGroup_ and _index_.
        1. If _result_ is *false*, return *false*.
        1. If |Elision| is present, then
          1. Let _result2_ be ? MatchElementEvaluation of |Elision| with arguments _matchable_, _cacheGroup_ and _index_.
          1. If _result2_ is *false*, return *false*.
        1. If |ArrayMatchPatternRestElement| is present, then
          1. Return ? MatchElementEvaluation of |ArrayMatchPatternRestElement| with arguments _matchable_, _cacheGroup_ and _index_.
        1. Return ? MatchIteratorLengthMatch(_cacheGroup_, _matchable_, index.[[LastIndex]]).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-match-property-evaluation" type="sdo">
      <h1>
        Runtime Semantics: ObjectMatchPatternPropertyEvaluation (
          _matchable_: an ECMAScript language value,
          _cacheGroup_: a %Map%,
        ): either a normal completion containing either ~not-matched~ or a List, or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ObjectMatchPatternPropertyList : ObjectMatchPatternProperty
      </emu-grammar>
      <emu-alg>
        1. Return ? ObjectMatchPatternPropertyEvaluation of |ObjectMatchPatternProperty| with arguments _matchable_ and _cacheGroup_.
      </emu-alg>
      <emu-grammar>
        ObjectMatchPatternPropertyList : ObjectMatchPatternPropertyList `,` ObjectMatchPatternProperty
      </emu-grammar>
      <emu-alg>
        1. Let _result_ be ? ObjectMatchPatternPropertyEvaluation of |ObjectMatchPatternPropertyList| with arguments _matchable_ and _cacheGroup_.
        1. If _result_ is ~not-matched~, return *false*.
        1. Let _result2_ be ? ObjectMatchPatternPropertyEvaluation of |ObjectMatchPatternProperty| with arguments _matchable_ and _cacheGroup_.
        1. If _result2_ is ~not-matched~, return *false*.
        1. Return the list-concatenation of _result_ and _result2_.
      </emu-alg>
      <emu-grammar>
        ObjectMatchPatternProperty : IdentifierMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _identifier_ be the |Identifier| that is covered by |IdentifierMatchPattern|.
        1. Let _name_ be the StringValue of _identifier_.
        1. If ? MatchCachedHasProperty(_cacheGroup_, _matchable_, _name_) is *false*, return *false*.
        1. Let _value_ be ? MatchCachedGet(_cacheGroup_, _matchable_, _name_).
        1. Perform AddMatchBinding(_name_, _value_).
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        ObjectMatchPatternProperty : PropertyName `:` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _propKey_ be ? Evaluation of |PropertyName|.
        1. ReturnIfAbrupt(propKey).
        1. If ? MatchCachedHasProperty(_cacheGroup_, _matchable_, _propKey_) is *false*, return *false*.
        1. Let _value_ be ? MatchCachedGet(_cacheGroup_, _matchable_, _propKey_).
        1. Return ? MatchPatternMatches of |MatchPattern| with arguments _value_ and _cacheGroup_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-match-rest-property-evaluation" type="sdo">
      <h1>
        Runtime Semantics: MatchRestPropertyEvaluation (
          _matchable_: an ECMAScript language value,
          _cacheGroup_: a %Map%,
          _excludedNames_: a List,
        ): either a normal completion containing ~unused~ or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        MatchRestProperty : `...` IdentifierMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _identifier_ be the |Identifier| that is covered by |IdentifierMatchPattern|.
        1. Let _name_ be the StringValue of _identifier_.
        1. Let _rest_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ? CopyDataProperties(_rest_, _matchable_, _excludedNames_).
        1. Perform AddMatchBinding(_name_, _rest).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-match-element-evaluation" type="sdo">
      <h1>
        Runtime Semantics: MatchElementEvaluation (
          _matchable_: an ECMAScript language value,
          _cacheGroup_: a %Map%,
          _counter_: a Record,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ArrayMatchPatternRestElement : `...` MatchPattern?
      </emu-grammar>
      <emu-alg>
        1. If |MatchPattern| is not present, return *true*.
        1. Let _iteratorRecord_ be ? MatchCachedGetIterator(_cacheGroup_, _matchable_).
        1. Let _A_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. Repeat,
          1. Let _next_ be ? MatchCachedIteratorStep(_cacheGroup_, _iteratorRecord_).
          1. If _iteratorRecord_.[[Matched]] is *false*, then
            1. Return ? MatchPatternMatches of |MatchPattern| with arguments _A_ and _cacheGroup_.
          1. Perform ! CreateDataPropertyOrThrow(A, ! ToString(ùîΩ(n)), _next_.[[Value]]).
          1. Set _n_ to _n_ + 1.
      </emu-alg>
      <emu-grammar>
        ArrayMatchPatternElementList : ArrayMatchPatternElisionElement
      </emu-grammar>
      <emu-alg>
        1. Return ? MatchElementEvaluation of |ArrayMatchPatternElisionElement| with arguments _matchable_, _cacheGroup_, and _counter_.
      </emu-alg>
      <emu-grammar>
        ArrayMatchPatternElementList : ArrayMatchPatternElementList `,` ArrayMatchPatternElisionElement
      </emu-grammar>
      <emu-alg>
        1. Let _result_ be ? MatchElementEvaluation of |ArrayMatchPatternElementList| with arguments _matchable_, _cacheGroup_, and _counter_.
        1. If _result_ is *false*, return *false*.
        1. Return ? MatchElementEvaluation of |ArrayMatchPatternElisionElement| with arguments _matchable_, _cacheGroup_, and _counter_.
      </emu-alg>
      <emu-grammar>
        ArrayMatchPatternElisionElement : Elision? MatchPattern
      </emu-grammar>
      <emu-alg>
        1. If |Elision| is present, then
          1. Let _result_ be ? MatchElementEvaluation of |Elision| with arguments _matchable_, _cacheGroup_, and _counter_.
          1. If _result_ is *false*, return *false*.
        1. Let _value_ be ? MatchCachedGetIteratorNthItem(_cacheGroup_, _matchable_, _counter_.[[LastIndex]]).
        1. If _value_.[[Matched]] is *false*, return *false*.
        1. Let _result2_ be ? MatchPatternMatches of |MatchPattern| with arguments _value_.[[Value]] and _cacheGroup_.
        1. If _result2_ is *false*, return *false*.
        1. Set _counter_.[[LastIndex]] to _counter_.[[LastIndex]] + 1.
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        Elision : `,`
      </emu-grammar>
      <emu-alg>
        1. Let _result_ be ? MatchCachedGetIteratorNthItem(_cacheGroup_, _matchable_, _counter_.[[LastIndex]]).
        1. If _result_.[[Matched]] is *false*, return *false*.
        1. Set _counter_.[[LastIndex]] to _counter_.[[LastIndex]] + 1.
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        Elision : Elision `,`
      </emu-grammar>
      <emu-alg>
        1. Let _result_ be ? MatchElementEvaluation of |Elision| with arguments _matchable_, _cacheGroup_, and _counter_.
        1. If _result_ is *false*, return *false*.
        1. Let _result2_ be ? MatchCachedGetIteratorNthItem(_cacheGroup_, _matchable_, _counter_.[[LastIndex]]).
        1. If _result2_.[[Matched]] is *false*, return *false*.
        1. Set _counter_.[[LastIndex]] to _counter_.[[LastIndex]] + 1.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-record">
      <h1><ins>Match Records</ins></h1>
      <p>A Match Record is a Record value used to represent the match result of the match clause.</p>
      <p>Match Record have the fields listed in Table 1.</p>
      <emu-table>
        <emu-caption>Table 1</emu-caption>
        <table>
          <tr><th>Field Name</th><th>Value</th><th>Meaning</th></tr>
          <tr><td>[[Matched]]</td><td>a Boolean</td><td>If the match clause matched.</td></tr>
          <tr><td>[[Value]]</td><td>an ECMAScript language value or ~unused~</td><td>The matched value.</td></tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-custom-matcher" type="abstract operation">
      <h1><ins>
        InvokeCustomMatcher (
          _val_: an ECMAScript language value,
          _matchable_: an ECMAScript language value,
        ): either a normal completion containing either an ECMAScript language value or ~not-matched~, or an abrupt completion
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If Type(_val_) is not Object, then
          1. If SameValueZero(_val_, _matchable_), return _val_.
          1. Return ~not-matched~.
        1. Let _matcher_ be ? Get(_val_, @@matcher).
        1. If IsCallable(_matcher_) is *false*, throw a *TypeError* exception.
        1. Let _result_ be ? Call(_matcher_, _val_, ¬´ _matchable_ ¬ª).
        1. If Type(_result_) is Boolean, then
          1. If _result_ is *false*, return ~not-matched~.
          1. Return _val_.
        1. If Type(_result_) is not Object, throw a *TypeError* exception.
        1. Let _matched_ be ToBoolean(? Get(_result_, *"matched"*)).
        1. If _matched_ is *false*, return ~not-matched~.
        1. Return ? Get(_result_, *"value"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-regex-named-capture-group-binding" type="abstract operation">
      <h1><ins>
        RegularExpressionNamedCaptureGroupBindingInitialization (
          _regexMatchResult_: an Array,
        ): ~unused~
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _groups_ be ! Get(_regexMatchResult_, *"groups"*).
        1. If _groups_ is *undefined*, return.
        1. Let _bindings_ be ! GetOwnPropertyKeys(_groups_, ~String~).
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _matchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Set the running execution context's LexicalEnvironment to _matchEnv_.
        1. For each element _name_ of _bindings_, do
          1. Perform ! _matchEnv_.CreateImmutableBinding(_name_, *true*).
          1. Perform ! _matchEnv_.InitializeBinding(_name_, ! Get(_groups_, _name_)).
      </emu-alg>
      <emu-note>
        The object _regexMatchResult_ that is used in this Abstract Operation is not accessible from user code. An implementation may choose to avoid the actual creation of the object.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-get-match-cache" type="abstract operation">
      <h1><ins>
        GetMatchCache (
          _cacheGroup_: a Map,
          _object_: an ECMAScript language value,
        ): an ECMAScript language value
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If ! Call(%Map.prototype.has%, _cacheGroup_, ¬´ _object_ ¬ª) is *true*, then
          1. Return ! Call(%Map.prototype.get%, _cacheGroup_, ¬´ _object_ ¬ª).
        1. Let _cache_ be OrdinaryObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_cache_, *"Has"*, ! Construct(%Set%, *undefined*, a new empty List)).
        1. Perform ! CreateDataPropertyOrThrow(_cache_, *"Get"*, ! Construct(%Map%, *undefined*, a new empty List)).
        1. Perform ! CreateDataPropertyOrThrow(_cache_, *"Iterator"*, *undefined*).
        1. Perform ! CreateDataPropertyOrThrow(_cache_, *"IteratedItems"*, ! ArrayCreate(0)).
        1. Perform ! Call(%Map.prototype.set%, _cacheGroup_, ¬´ _object_, _cache_ ¬ª).
        1. Return _cache_.
      </emu-alg>
      <emu-note>
        The object _cache_ and all of its data properties are not accessible from user code. An implementation may choose to avoid the actual creation of the object.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-match-cached-has-property" type="abstract operation">
      <h1><ins>
        MatchCachedHasProperty (
          _cacheGroup_: a Map,
          _object_: an ECMAScript language value,
          _propertyName_: a property key,
        ): either a normal completion containing a Boolean or an abrupt completion
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _cache_ be ! Get(GetMatchCache(_cacheGroup_, _object_), *"Has"*).
        1. Let _cachedResult_ be ! Call(%Map.prototype.get%, _cache_, ¬´ _propertyName_ ¬ª).
        1. If Type(_cachedResult_) is Boolean, return _cachedResult_.
        1. Let _result_ be ? HasProperty(_object_, _propertyName_).
        1. Perform ! Call(%Map.prototype.set%, _cache_, ¬´ _propertyName_, _result_ ¬ª).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-cached-get" type="abstract operation">
      <h1><ins>
        MatchCachedGet (
          _cacheGroup_: a Map,
          _object_: an ECMAScript language value,
          _propertyName_: a property key,
        ): either a normal completion containing an ECMAScript language value or an abrupt completion
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _cache_ be ! Get(GetMatchCache(_cacheGroup_, _object_), *"Get"*).
        1. Let _hasCache_ be ! Call(%Map.prototype.has%, _cache_, ¬´ _propertyName_ ¬ª).
        1. If _hasCache_ is *true*, return ! Call(%Map.prototype.get%, _cache_, ¬´ _propertyName_ ¬ª).
        1. Let _result_ be ? Get(_object_, _propertyName_).
        1. Perform ! Call(%Map.prototype.set%, _cache_, ¬´ _propertyName_, _result_ ¬ª).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-cached-is-iterable" type="abstract operation">
      <h1><ins>
        MatchCachedIsIterable (
          _cacheGroup_: a Map,
          _object_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _iter_ be ? MatchCachedGet(_cacheGroup_, _object_, @@iterator).
        1. If Type(_iter_) is not Function, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-cached-get-iterator" type="abstract operation">
      <h1><ins>
        MatchCachedGetIterator (
          _cacheGroup_: a Map,
          _object_: an ECMAScript language value,
        ): either a normal completion containing an Iterator Record or an abrupt completion
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _cache_ be GetMatchCache(_cacheGroup_, _object_).
        1. Let _iter_ be ! Get(_cache_, *"Iterator"*).
        1. If _iter_ is not *undefined*, return _iter_.[[CachedIterator]].
        1. Let _f_ be ? MatchCachedGet(_cacheGroup_, _object_, @@iterator).
        1. Set _iter_ to OrdinaryObjectCreate(*null*, ¬´ [[CachedIterator]] ¬ª).
        1. Set _iter_.[[CachedIterator]] to ? GetIteratorFromMethod(_object_, _f_).
        1. Perform ! Set(_cache_, *"Iterator"*, _iter_, *true*).
        1. Perform ! Call(%Set.prototype.add%, ! Get(_cacheGroup_, *"IteratorToClose"*), ¬´ _iter_ ¬ª).
        1. Return _iter_.[[CachedIterator]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-cached-iterator-step" type="abstract operation">
      <h1><ins>
        MatchCachedIteratorStep (
          _cacheGroup_: a Map,
          _iterator_: an Iterator Record,
        ): either a normal completion containing a Match Record or an abrupt completion
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _iterator_.[[Done]] is *true*, return CreateMatchRecord(*false*).
        1. Let _cache_ be GetMatchCache(_cacheGroup_, _iterator_).
        1. Let _cachedItems_ be ! Get(_cache_, *"IteratedItems"*).
        1. Let _iterResult_ be Completion(IteratorStep(_iterator_)).
        1. If _iterResult_ is an abrupt completion, set _iterator_.[[Done]] to *true*.
        1. ReturnIfAbrupt(_iterResult_).
        1. If _iterResult_ is *false*, then
          1. Set _iterator_.[[Done]] to *true*.
          1. Return CreateMatchRecord(*false*).
        1. Let _value_ be Completion(IteratorValue(_iterResult_)).
        1. If _value_ is an abrupt completion, set _iterator_.[[Done]] to *true*.
        1. ReturnIfAbrupt(_value_).
        1. Perform ! Call(%Array.prototype.push%, _cachedItems_, ¬´ _value_ ¬ª).
        1. Return CreateMatchRecord(*true*, _value_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-cached-get-iterator-nth-item" type="abstract operation">
      <h1><ins>
        MatchCachedGetIteratorNthItem (
          _cacheGroup_: a Map,
          _iterator_: an Iterator Record,
          _n_: a Number,
        ): either a normal completion containing a Match Record or an abrupt completion
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _cache_ be GetMatchCache(_cacheGroup_, _iterator_).
        1. Let _cachedItems_ be ! Get(_cache_, *"IteratedItems"*).
        1. Let _nthItem_ be ! _cachedItems_.[[GetOwnProperty]](_n_).
        1. If _nthItem_ is not *undefined*, return CreateMatchRecord(*true*, _nthItem_.[[Value]]).
        1. If _iterator_.[[Done]] is *true*, return CreateMatchRecord(*false*).
        1. Return ? MatchCachedIteratorStep(_cacheGroup_, _iterator_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-match-iterator-length-match" type="abstract operation">
      <h1><ins>
        MatchIteratorLengthMatch (
          _cacheGroup_: a Map,
          _matchable_: an ECMAScript language value,
          _lastIndex_: a Number,
        ): either a normal completion containing a Boolean or an abrupt completion
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _iterator_ be ? MatchCachedGetIterator(_cacheGroup_, _matchable_).
        1. Let _cache_ be GetMatchCache(_cacheGroup_, _iterator_).
        1. Let _cachedItems_ be ! Get(_cache_, *"IteratedItems"*).
        1. Let _length_ be ! Get(_cachedItems_, *"length"*).
        1. If _lastIndex_ &gt; -1, then
          1. If _length_ &gt; _lastIndex_, return *false*.
          1. If _iter ator_.[[Done]] is *true*, then
            1. If _length_ = _lastIndex_, return *true*.
            1. Return *false*.
        1. Let _iterResult_ be ? MatchCachedGetIteratorNthItem(_cacheGroup_, _iterator_, _lastIndex_ + 1).
        1. If _iterResult_.[[Matched]] is *true*, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-close-iterators" type="abstract operation">
      <h1><ins>
        CloseIterators (
          _iterators_: a List of Iterator Records
        ): either a normal completion containing ~unused~ or a throw completion
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _errors_ be a new empty List.
        1. For each element _iter_ of _iterators_, do
          1. If _iter_.[[Done]] is *false*, then
            1. Let _completion_ be Completion(IteratorClose(_iter_, NormalCompletion(*undefined*))).
            1. If _completion_ is an abrupt completion, append _completion_.[[Value]] to _errors_.
        1. If _errors_ is not empty, then
          1. If length of _errors_ is 1, return ThrowCompletion(_errors_[0]).
          1. Let _error_ be a newly created AggregateError object.
          1. Perform ! DefinePropertyOrThrow(_error_, "errors", PropertyDescriptor { [[Configurable]]: true, [[Enumerable]]: false, [[Writable]]: true, [[Value]]: CreateArrayFromList(errors) }).
          1. Return ThrowCompletion(_error_).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-add-match-binding" type="abstract operation">
      <h1><ins>
        AddMatchBinding (
          _name_: a String,
          _value_: an ECMAScript language value
        ): ~unused~
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _matchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Set the running execution context's LexicalEnvironment to _matchEnv_.
        1. Perform ! _matchEnv_.CreateImmutableBinding(_name_, *true*).
        1. Perform ! _matchEnv_.InitializeBinding(_name_, _value_).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-relational-operators" number="10">
  <h1>Relational Operators</h1>
  <h2>Syntax</h2>
  <emu-grammar>
    RelationalExpression[In, Yield, Await]:
      ShiftExpression[?Yield, ?Await]
      RelationalExpression[?In, ?Yield, ?Await] `<` ShiftExpression[?Yield, ?Await]
      RelationalExpression[?In, ?Yield, ?Await] `>` ShiftExpression[?Yield, ?Await]
      RelationalExpression[?In, ?Yield, ?Await] `<=` ShiftExpression[?Yield, ?Await]
      RelationalExpression[?In, ?Yield, ?Await] `>=` ShiftExpression[?Yield, ?Await]
      RelationalExpression[?In, ?Yield, ?Await] `instanceof` ShiftExpression[?Yield, ?Await]
      <ins>RelationalExpression[?In, ?Yield, ?Await] [no LineTerminator here] `is` MatchPattern[?Yield, ?Await]</ins>
      [+In] RelationalExpression[+In, ?Yield, ?Await] `in` ShiftExpression[?Yield, ?Await]
      [+In] PrivateIdentifier `in` ShiftExpression[?Yield, ?Await]
  </emu-grammar>
  <emu-clause id="sec-relational-operators-runtime-semantics-evaluation">
    <h1>Runtime Semantics: Evaluation</h1>
    <emu-grammar>
      <ins>RelationalExpression: RelationalExpression `is` MatchPattern[?Yield, ?Await]</ins>
    </emu-grammar>
    <emu-alg>
      1. Let _matchable_ be ? Evaluation of |RelationalExpression|.
      1. Let _cacheGroup_ be ! Construct(%Map%, a new empty List).
      1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
      1. Let _matchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
      1. Set the running execution context's LexicalEnvironment to _matchEnv_.
      1. Let _result_ be Completion(MatchPatternMatches of |MatchPattern| with arguments _matchable_ and _cacheGroup_).
      1. Set the running execution context's LexicalEnvironment to _oldEnv_.
      1. Return ? _result_.
    </emu-alg>
  </emu-clause>
</emu-clause>
</emu-clause>

<emu-clause id="sec-fundamental-objects" number="20">
  <h1>Fundamental Objects</h1>

  <emu-clause id="sec-object-objects">
    <h1>Object Objects</h1>

    <emu-clause id="sec-properties-of-the-object-constructor" number="2">
      <h1>Properties of the Object Constructor</h1>

      <emu-clause id="sec-object-@@matcher" number="23">
        <h1><ins>Object [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is an Object.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-objects">
    <h1>Function Objects</h1>

    <emu-clause id="sec-properties-of-the-function-constructor" number="2">
      <h1>Properties of the Function Constructor</h1>

      <emu-clause id="sec-function-@@matcher" number="3">
        <h1><ins>Function [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Function.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If IsCallable(_value_) is *false*, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this* value, *"%Function%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-prototype-object">
      <h1>Properties of the Function Prototype Object</h1>

      <emu-clause id="sec-function-prototype-@@matcher" number="7">
        <h1><ins>Function.prototype [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Function, or an instance of a class constructor.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Return ? MatchConstructorInstance(_value_, *this* value).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-boolean-objects">
    <h1>Boolean Objects</h1>

    <emu-clause id="sec-properties-of-the-boolean-constructor" number="2">
      <h1>Properties of the Boolean Constructor</h1>

      <emu-clause id="sec-boolean-@@matcher" number="2">
        <h1><ins>Boolean [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Boolean.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(thisBooleanValue(_value_)).
          1. If _result_ is an abrupt completion, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-prototype-object">
      <h1>Properties of the Boolean Prototype Object</h1>

      <emu-clause id="sec-boolean-prototype-@@matcher" number="4">
        <h1><ins>Boolean.prototype [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a matching Boolean.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _B_ be ? thisBooleanValue(*this value*).
          1. Let _result_ be Completion(thisBooleanValue(_value_)).
          1. If _result_ is an abrupt completion or SameValue(_B_, _result_) is *false*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-symbol-objects">
    <h1>Symbol Objects</h1>

    <emu-clause id="sec-properties-of-the-symbol-constructor" number="2">
      <h1>Properties of the Symbol Constructor</h1>

      <emu-clause id="sec-symbol-@@matcher" number="17">
        <h1><ins>Symbol [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Symbol.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(thisSymbolValue(_value_)).
          1. If _result_ is an abrupt completion, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-prototype-object">
      <h1>Properties of the Symbol Prototype Object</h1>

      <emu-clause id="sec-symbol-prototype-@@matcher" number="5">
        <h1><ins>Symbol.prototype [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is the same Symbol.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be ? thisSymbolValue(*this value*).
          1. Let _result_ be Completion(thisSymbolValue(_value_)).
          1. If _result_ is an abrupt completion or SameValue(_S_, _result_) is *false*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-error-objects">
    <h1>Error Objects</h1>

    <emu-clause id="sec-properties-of-the-error-constructor" number="2">
      <h1>Properties of the Error Constructor</h1>

      <emu-clause sec id="error-@@matcher" number="2">
        <h1><ins>Error [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is an Error.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have an [[ErrorData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this* value, *"%Error%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-nativeerror-object-structure" number="6">
      <h1>_NativeError_ Object Structure</h1>

      <emu-clause id="sec-properties-of-the-nativeerror-constructors" number="2">
        <h1>Properties of the _NativeError_ Constructors</h1>

        <emu-clause sec id="nativeerror-@@matcher" number="2">
          <h1><ins>_NativeError_ [ @@matcher ] ( _value_ )</ins></h1>
          <p>This function is called by ECMAScript pattern matching to determine if the value is a <code><var>NativeError</var></code>.</p>
          <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
          <emu-alg>
            1. If Type(_value_) is not Object, or if _value_ does not have an [[ErrorData]] internal slot, return CreateMatchResultObject(*false*).
            1. Let _intrinsicName_ be the string-concatenation of *"%"*, the String value consisting of the name of the constructor (the name used instead of _NativeError_), and "*%*".
            1. Return ? MatchConstructorInstance(_value_, *this* value, _intrinsicName_).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-aggregate-error-objects">
      <h1>AggregateError Objects</h1>

      <emu-clause id="sec-aggregate-error-constructor">
        <h1>The AggregateError Constructor</h1>

        <emu-clause id="sec-aggregate-error">
          <h1>AggregateError ( _errors_, _message_ [ , _options_ ] )</h1>
          <p>When the *AggregateError* function is called with arguments _errors_ and _message_ and optional argument _options_, the following steps are taken:</p>
          <emu-alg>
            1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.
            1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%AggregateError.prototype%"*, &laquo; [[ErrorData]] &raquo;).
            1. If _message_ is not *undefined*, then
              1. Let _msg_ be ? ToString(_message_).
              1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_).
            1. Perform ? InstallErrorCause(_O_, _options_).
            1. Let _errorsList_ be ? IteratorToList(? GetIterator(_errors_, ~sync~)).
            1. Perform ! DefinePropertyOrThrow(_O_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errorsList_) }).
            1. Return _O_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-constructor">
        <h1>Properties of the AggregateError Constructor</h1>

        <emu-clause sec id="aggregate-error-@@matcher" number="2">
          <h1><ins>AggregateError [ @@matcher ] ( _value_ )</ins></h1>
          <p>This function is called by ECMAScript pattern matching to determine if the value is an AggregateError.</p>
          <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
          <emu-alg>
            1. If Type(_value_) is not Object, or if _value_ does not have an [[ErrorData]] internal slot, return CreateMatchResultObject(*false*).
            1. Return ? MatchConstructorInstance(_value_, *this* value, *"%AggregateError%"*).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>

  <emu-clause id="sec-number-objects">
    <h1>Number Objects</h1>

    <emu-clause id="sec-properties-of-the-number-constructor" number="2">
      <h1>Properties of the Number Constructor</h1>

      <emu-clause id="sec-number-@@matcher" number="16">
        <h1><ins>Number [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Number.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(thisNumberValue(_value_)).
          1. If _result_ is an abrupt completion, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-prototype-object">
      <h1>Properties of the Number Prototype Object</h1>

      <emu-clause id="sec-number-prototype-@@matcher" number="8">
        <h1><ins>Number.prototype [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is the same Number.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _N_ be ? thisNumberValue(*this value*).
          1. Let _result_ be Completion(thisNumberValue(_value_)).
          1. If _result_ is an abrupt completion or SameValueZero(_N_, _result_) is *false*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bigint-objects">
    <h1>BigInt Objects</h1>

    <emu-clause id="sec-properties-of-the-bigint-constructor" number="2">
      <h1>Properties of the BigInt Constructor</h1>

      <emu-clause id="sec-bigint-@@matcher" number="4">
        <h1><ins>BigInt [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a BigInt.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(thisBigIntValue(_value_)).
          1. If _result_ is an abrupt completion, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-prototype-object">
      <h1>Properties of the BigInt Prototype Object</h1>

      <emu-clause id="sec-bigint-prototype-@@matcher" number="6">
        <h1><ins>BigInt.prototype [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is the same BigInt.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _B_ be ? thisBigIntValue(*this value*).
          1. Let _result_ be Completion(thisBigIntValue(_value_)).
          1. If _result_ is an abrupt completion or SameValue(_B_, _result_) is *false*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-date-objects" number="4">
    <h1>Date Objects</h1>

    <emu-clause id="sec-properties-of-the-date-constructor" number="3">
      <h1>Properties of the Date Constructor</h1>

      <emu-clause sec id="date-@@matcher" number="5">
        <h1><ins>Date [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Date.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[DateValue]] internal slot, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this* value, *"%Date%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-text-processing">
  <h1>Text Processing</h1>

  <emu-clause id="sec-string-objects">
    <h1>String Objects</h1>

    <emu-clause id="sec-properties-of-the-string-constructor" number="2">
      <h1>Properties of the String Constructor</h1>

      <emu-clause sec id="string-@@matcher" number="5">
        <h1><ins>String [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a String.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(thisStringValue(_value_)).
          1. If _result_ is an abrupt completion, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-prototype-object">
      <h1>Properties of the String Prototype Object</h1>

      <emu-clause id="sec-string-prototype-@@matcher" number="35">
        <h1><ins>String.prototype [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is the same String.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _S_ be ? thisStringValue(*this value*).
          1. Let _result_ be Completion(thisStringValue(_value_)).
          1. If _result_ is an abrupt completion or SameValue(_S_, _result_) is *false*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-regexp-regular-expression-objects">
    <h1>RegExp (Regular Expression) Objects</h1>

    <emu-clause id="sec-properties-of-the-regexp-constructor" number="4">
      <h1>Properties of the RegExp Constructor</h1>

      <emu-clause sec id="regexp-@@matcher">
        <h1><ins>RegExp [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a RegExp.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(IsRegExp(_value_)).
          1. If _result_ is an abrupt completion, or if _result_.[[Value]] is *false*, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this* value, *"%RegExp%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-prototype-object">
      <h1>Properties of the RegExp Prototype Object</h1>

      <emu-clause sec id="regexp-prototype-@@matcher" number="10">
        <h1><ins>RegExp.prototype [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value matches the RegExp.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).
          1. Let _result_ be ? RegExpBuiltinExec(_R_, ? ToString(_value_)).
          1. If _result_ is *null*, return CreateMatchResultObject(*false*).
          1. Return CreateMatchResultObject(*true*, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-indexed-collections">
  <h1>Indexed Collections</h1>

  <emu-clause id="sec-array-objects">
    <h1>Array Objects</h1>

    <emu-clause id="sec-properties-of-the-array-constructor">
      <h1>Properties of the Array Constructor</h1>

      <emu-clause sec id="array-@@matcher" number="6">
        <h1><ins>Array [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is an Array.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _result_ be Completion(IsArray(_value_)).
          1. If _result_ is an abrupt completion, or if _result_.[[Value]] is *false*, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this* value, *"%Array%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-objects">
    <h1>TypedArray Objects</h1>

    <emu-clause id="sec-properties-of-the-typedarray-constructors" number="6">
      <h1>Properties of the _TypedArray_ Constructors</h1>

      <emu-clause sec id="typedarray-@@matcher" number="3">
        <h1><ins>_TypedArray_ [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a _TypedArray_.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, return CreateMatchResultObject(*false*).
          1. If _value_ does not have a [[TypedArrayName]] internal slot, return CreateMatchResultObject(*false*).
          1. If _value_.[[TypedArrayName]] is not _TypedArray_, return CreateMatchResultObject(*false*).
          1. Let _intrinsicName_ be the string-concatenation of *"%"*, _value_.[[TypedArrayName]], and "*%*".
          1. Return ? MatchConstructorInstance(_value_, *this value*, _intrinsicName_).
        </emu-alg>
        <emu-note type="editor">TODO: probably i need to convert _TypedArray_ into a string to be able to do the comparison to the internal slot.</emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-keyed-collections" oldids="sec-keyed-collection">
  <h1>Keyed Collections</h1>

  <emu-clause id="sec-map-objects">
    <h1>Map Objects</h1>

    <emu-clause id="sec-properties-of-the-map-constructor" number="2">
      <h1>Properties of the Map Constructor</h1>

      <emu-clause sec id="map-@@matcher" number="3">
        <h1><ins>Map [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Map.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[MapData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this value*, *"%Map%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-set-objects">
    <h1>Set Objects</h1>

    <emu-clause id="sec-properties-of-the-set-constructor" number="2">
      <h1>Properties of the Set Constructor</h1>

      <emu-clause sec id="set-@@matcher" number="3">
        <h1><ins>Set [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Set.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[SetData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this value*, *"%Set%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakmap-objects">
    <h1>WeakMap Objects</h1>

    <emu-clause id="sec-properties-of-the-weakmap-constructor" number="2">
      <h1>Properties of the WeakMap Constructor</h1>

      <emu-clause sec id="weakmap-@@matcher" number="2">
        <h1><ins>WeakMap [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a WeakMap.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[WeakMapData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this value*, *"%WeakMap%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakset-objects">
    <h1>WeakSet Objects</h1>

    <emu-clause id="sec-properties-of-the-weakset-constructor" number="2">
      <h1>Properties of the WeakSet Constructor</h1>

      <emu-clause sec id="weakset-@@matcher" number="2">
        <h1><ins>WeakSet [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a WeakSet.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[WeakSetData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this value*, *"%WeakSet%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-structured-data">
  <h1>Structured Data</h1>

  <emu-clause id="sec-arraybuffer-objects">
    <h1>ArrayBuffer Objects</h1>

    <emu-clause id="sec-properties-of-the-arraybuffer-constructor" number="4">
      <h1>Properties of the ArrayBuffer Constructor</h1>

      <emu-clause sec id="arraybuffer-@@matcher" number="4">
        <h1><ins>ArrayBuffer [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is an ArrayBuffer.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have an [[ArrayBufferData]] internal slot, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this value*, *"%ArrayBuffer%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-objects">
    <h1>SharedArrayBuffer Objects</h1>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-constructor" number="3">
      <h1>Properties of the SharedArrayBuffer Constructor</h1>

      <emu-clause sec id="sharedarraybuffer-@@matcher" number="3">
        <h1><ins>SharedArrayBuffer [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a SharedArrayBuffer.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have an [[ArrayBufferData]] internal slot, return CreateMatchResultObject(*false*).
          1. If IsSharedArrayBuffer(_value_) is *false*, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this value*, *"%SharedArrayBuffer%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-objects">
    <h1>DataView Objects</h1>

    <emu-clause id="sec-properties-of-the-dataview-constructor" number="3">
      <h1>Properties of the DataView Constructor</h1>

      <emu-clause sec id="dataview-@@matcher" number="2">
        <h1><ins>DataView [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a DataView.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[DataView]] internal slot, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this value*, *"%DataView%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-managing-memory">
  <h1>Managing Memory</h1>

  <emu-clause id="sec-weak-ref-objects">
    <h1>WeakRef Objects</h1>

    <emu-clause id="sec-properties-of-the-weak-ref-constructor" number="2">
      <h1>Properties of the WeakRef Constructor</h1>

      <emu-clause sec id="weak-ref-@@matcher" number="2">
        <h1><ins>WeakRef [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a WeakRef.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[WeakRefTarget]] internal slot, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this value*, *"%WeakRef%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-finalization-registry-objects">
    <h1>FinalizationRegistry Objects</h1>

    <emu-clause id="sec-properties-of-the-finalization-registry-constructor" number="2">
      <h1>Properties of the FinalizationRegistry Constructor</h1>

      <emu-clause sec id="finalization-registry-@@matcher" number="2">
        <h1><ins>FinalizationRegistry [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a FinalizationRegistry.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_value_) is not Object, or if _value_ does not have a [[Cells]] internal slot, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this value*, *"%FinalizationRegistry%"*).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>Control Abstraction Objects</h1>

  <emu-clause id="sec-promise-objects" number="2">
    <h1>Promise Objects</h1>

    <emu-clause id="sec-properties-of-the-promise-constructor" number="4">
      <h1>Properties of the Promise Constructor</h1>

      <emu-clause sec id="promise-@@matcher" number="9">
        <h1><ins>Promise [ @@matcher ] ( _value_ )</ins></h1>
        <p>This function is called by ECMAScript pattern matching to determine if the value is a Promise.</p>
        <p>When the `@@matcher` method is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If IsPromise(_value_) is *false*, return CreateMatchResultObject(*false*).
          1. Return ? MatchConstructorInstance(_value_, *this value*, *"%Promise%"*).
        </emu-alg>
        <emu-note type="editor">
          TODO: decide if we want to loosen this to accept thenables, breaking with the precedent set here by the rest of the built-in matchers.
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-todo" number="1000">
  <h1>TODO</h1>

  <emu-clause id="todo-constructors">
    <h1>Confirm we do not want matchers for these constructors</h1>
    <emu-alg>
      1. Iterator/AsyncIterator (probably when Iterator Helpers advances).
      1. Record/Tuple (definintely when R&T advances).
      1. GeneratorFunction/AsyncFunction/AsyncGeneratorFunction (maybe).
      1. Generator/AsyncGenerator (probably not).
      1. Proxy (definitely not).
    </emu-alg>
  </emu-clause>

  <emu-clause id="todo-object-instances">
    <h1>Should we add builtin matchers on the prototype for relevant class instances, so they do something useful?</h1>
    <emu-alg>
      1. Date: should compare the time value, and not identity.
      1. RegExp: should compare pattern/flags, and maybe lastIndex?.
      1. Array/Typed Array/Map/Set: should match type, and then iterate and match against contents?.
    </emu-alg>
  </emu-clause>
</emu-clause>
